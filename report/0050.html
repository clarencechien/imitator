<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>元大台灣50 (0050) 投資績效解析 - 智慧投資風格 (v4)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #F3F4F6; /* Light Gray - Smart Investing BG */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 320px; /* Base height for Chart.js charts */
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .canvas-info-card {
            width: 100%; /* Canvas will take full width of its Tailwind grid parent */
            height: 260px; /* Fixed height for these specific canvas cards */
        }
         .flowchart-canvas-container {
            width: 100%;
            margin-left: auto;
            margin-right: auto;
        }
        .flowchart-canvas {
            width: 100%; /* Canvas element takes full width of container */
            height: 180px; /* Desktop height for flowchart canvas */
        }
        @media (max-width: 767px) {
            .flowchart-canvas {
                 height: 480px; /* Taller for mobile stacked flowchart */
            }
            .canvas-info-card {
                height: 240px; /* Slightly smaller for mobile */
            }
        }
    </style>
</head>
<body class="text-slate-700">

    <div class="container mx-auto p-4 md:p-6 lg:p-8">

        <header class="text-center mb-10 md:mb-16 py-6">
            <h1 class="text-4xl md:text-5xl lg:text-6xl font-bold text-[#3A506B] mb-3">元大台灣50 (0050)</h1>
            <p class="text-xl md:text-2xl text-[#5BC0BE]">十年投資績效・智慧解析</p>
        </header>

        <section id="hook" class="mb-10 md:mb-16">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8">
                <div class="bg-white rounded-xl shadow-lg p-1">
                    <canvas id="cumulativeReturnCanvas" class="canvas-info-card rounded-xl"></canvas>
                </div>
                <div class="bg-white rounded-xl shadow-lg p-1">
                    <canvas id="annualizedReturnCanvas" class="canvas-info-card rounded-xl"></canvas>
                </div>
            </div>
             <p class="text-center text-xs text-slate-500 mt-4">註：總報酬數據基於報告中2015/6/1至2025/5/29期間之臺灣50報酬指數估算值，實際報酬應以臺灣證券交易所歷史數據為準。</p>
        </section>

        <section id="total-return" class="bg-white rounded-xl shadow-lg p-6 md:p-8 mb-10 md:mb-16">
            <h2 class="text-2xl md:text-3xl font-bold text-[#3A506B] mb-4">總報酬深度解析：複利的威力</h2>
            <p class="text-slate-600 mb-6 leading-relaxed">總報酬是衡量投資績效最真實的指標，它不僅包含股價上漲帶來的資本利得，更關鍵的是將每年配發的股息進行再投資所產生的複利效果。下方的圖表模擬了臺灣50報酬指數在過去十年的增長軌跡，清晰地展示了長期堅持「股息再投資」策略所帶來的驚人成果。</p>
            <div class="chart-container">
                <canvas id="totalReturnChart"></canvas>
            </div>
             <p class="text-center text-xs text-slate-500 mt-4">圖表數據點為示意，旨在說明指數增長趨勢。期初與期末值對應報告中估算數據。</p>
        </section>

        <section id="dividend-performance" class="bg-white rounded-xl shadow-lg p-6 md:p-8 mb-10 md:mb-16">
            <h2 class="text-2xl md:text-3xl font-bold text-[#3A506B] mb-4">歷年股息表現 (2015-2024)</h2>
            <p class="text-slate-600 mb-6 leading-relaxed">0050不僅提供資本增值的潛力，也持續為投資者帶來現金流。此圖表整合了過去十年每股的現金股利總額（柱狀圖）與對應的年均殖利率（折線圖）。您可以觀察到，即使在某些殖利率因股價高漲而看似較低的年份，每股實際發放的現金股利金額仍可能處於高檔，這反映了成分企業穩健的獲利與派息能力。</p>
            <div class="chart-container">
                <canvas id="dividendChart"></canvas>
            </div>
             <p class="text-center text-xs text-slate-500 mt-4">資料來源：綜合整理自報告中引用的市場公開資訊。</p>
        </section>

        <section id="strategy" class="bg-white rounded-xl shadow-lg p-6 md:p-8 mb-10 md:mb-16">
            <h2 class="text-2xl md:text-3xl font-bold text-[#3A506B] mb-4">投資策略：簡單而強大</h2>
            <p class="text-slate-600 mb-8 leading-relaxed">0050的成功在於其清晰的被動式投資策略。它不試圖預測市場、挑選個股，而是透過「完全複製法」緊密追蹤臺灣50指數，讓投資者能以低成本、高效率的方式，一次性參與台灣50家最具代表性龍頭企業的長期發展。</p>
            <div class="flowchart-canvas-container">
                <canvas id="flowChartCanvas" class="flowchart-canvas"></canvas>
            </div>
        </section>

        <section id="conclusion" class="py-6 md:py-8">
            <h2 class="text-2xl md:text-3xl font-bold text-[#3A506B] text-center mb-6 md:mb-8">核心洞察與投資智慧</h2>
            <div class="max-w-3xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8">
                <p class="text-slate-600 mb-6 leading-relaxed">回顧過去十年，0050 ETF為投資者提供了參與台灣經濟成長的絕佳途徑。其績效證明了幾項重要的投資原則：</p>
                <ul class="space-y-5">
                    <li class="flex items-start">
                        <span class="text-3xl text-[#5BC0BE] mr-4 shrink-0">📈</span>
                        <div>
                            <h3 class="font-semibold text-lg text-[#3A506B] mb-1">長期持有是關鍵</h3>
                            <p class="text-slate-600 leading-relaxed">市場雖有波動，但長期持有能有效捕捉台灣大型企業的增長趨勢，平滑短期震盪，獲得可觀的總報酬。</p>
                        </div>
                    </li>
                    <li class="flex items-start">
                        <span class="text-3xl text-[#F9A826] mr-4 shrink-0">💰</span>
                        <div>
                            <h3 class="font-semibold text-lg text-[#3A506B] mb-1">股息再投資的複利魔法</h3>
                            <p class="text-slate-600 leading-relaxed">將收到的股息持續投入，是加速資產累積的核心驅動力。總報酬指數的表現已完美詮釋了這一點。</p>
                        </div>
                    </li>
                    <li class="flex items-start">
                        <span class="text-3xl text-red-500 mr-4 shrink-0">🎯</span>
                        <div>
                            <h3 class="font-semibold text-lg text-[#3A506B] mb-1">分散投資的力量</h3>
                            <p class="text-slate-600 leading-relaxed">透過持有50家不同產業的龍頭股，0050有效分散了單一個股的風險，讓投資更穩健。</p>
                        </div>
                    </li>
                </ul>
                <p class="mt-8 text-sm text-slate-500 text-center">過去的績效不保證未來的回報。任何投資決策均應基於個人的財務狀況與風險承受能力。</p>
            </div>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const smartInvestorProPalette = {
                primaryBlue: '#3A506B',    // Deep, trustworthy blue
                secondaryTeal: '#5BC0BE',  // Brighter, modern teal
                secondaryTealTransparent: 'rgba(91, 192, 190, 0.75)', // secondaryTeal with alpha for bar chart
                lightAccentBg: '#E0E7EF', // Light grey-blue for backgrounds or cards
                neutralGrey: '#6B7280',   // For text
                textPrimary: '#2d3748', // Darker grey for main text
                white: '#FFFFFF',
                highlightGold: '#F9A826', // Muted gold/orange for accents
                dangerRed: '#EF4444', // For icons or specific highlights
                cardBg: '#FFFFFF', // Explicit card background
            };

            const wrapLabel = (label) => {
                const maxLength = 16;
                if (typeof label !== 'string' || label.length <= maxLength) {
                    return label;
                }
                const words = label.split(' ');
                const lines = [];
                let currentLine = '';
                words.forEach(word => {
                    if ((currentLine + ' ' + word).trim().length > maxLength) {
                        lines.push(currentLine.trim());
                        currentLine = word;
                    } else {
                        currentLine = (currentLine + ' ' + word).trim();
                    }
                });
                if (currentLine) {
                    lines.push(currentLine.trim());
                }
                return lines;
            };

            const tooltipTitleCallback = (tooltipItems) => {
                const item = tooltipItems[0];
                let label = item.chart.data.labels[item.dataIndex];
                if (Array.isArray(label)) {
                    return label.join(' ');
                } else {
                    return label;
                }
            };

            function wrapCanvasText(ctx, text, x, y, maxWidth, lineHeight, textAlign = 'center', baseFont = "13px 'Noto Sans TC'") {
                const words = text.split(' ');
                let line = '';
                let currentY = y;
                ctx.textAlign = textAlign;
                ctx.font = baseFont;

                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    let metrics = ctx.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line.trim(), x, currentY);
                        line = words[n] + ' ';
                        currentY += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line.trim(), x, currentY);
                return currentY + lineHeight;
            }
            
            function getResponsiveFontSize(baseSize, canvasWidth, referenceWidth = 400) {
                const scaleFactor = Math.min(1, canvasWidth / referenceWidth);
                return Math.max(baseSize * 0.7, baseSize * scaleFactor); // Ensure a minimum size
            }

            function drawBigNumberCanvas(canvasEl, titleText, valueText, valueUnit, descriptionText, colors) {
                if (!canvasEl) return;
                const ctx = canvasEl.getContext('2d');
                
                const dpr = window.devicePixelRatio || 1;
                const rect = canvasEl.getBoundingClientRect();
                
                canvasEl.width = rect.width * dpr;
                canvasEl.height = rect.height * dpr;
                ctx.scale(dpr, dpr);

                const trueCanvasWidth = rect.width;
                const trueCanvasHeight = rect.height;

                ctx.clearRect(0, 0, trueCanvasWidth, trueCanvasHeight);
                ctx.fillStyle = colors.cardBg; 
                ctx.fillRect(0, 0, trueCanvasWidth, trueCanvasHeight);

                const padding = trueCanvasWidth * 0.05; 
                const contentWidth = trueCanvasWidth - 2 * padding;
                let currentY = padding + getResponsiveFontSize(10, trueCanvasWidth);

                ctx.font = `500 ${getResponsiveFontSize(16, trueCanvasWidth)}px 'Noto Sans TC'`;
                ctx.fillStyle = colors.secondaryTeal;
                ctx.textAlign = 'center';
                ctx.fillText(titleText, trueCanvasWidth / 2, currentY);
                currentY += getResponsiveFontSize(30, trueCanvasWidth);

                const valueFontSize = getResponsiveFontSize(52, trueCanvasWidth);
                ctx.font = `bold ${valueFontSize}px 'Noto Sans TC'`;
                ctx.fillStyle = colors.highlightGold;
                ctx.textBaseline = 'alphabetic';

                const valueTextWidth = ctx.measureText(valueText).width;
                const unitFontSize = getResponsiveFontSize(42, trueCanvasWidth, 500); 
                ctx.font = `bold ${unitFontSize}px 'Noto Sans TC'`;
                const unitTextWidth = ctx.measureText(valueUnit).width;
                
                const totalValueUnitWidth = valueTextWidth + unitTextWidth + getResponsiveFontSize(5, trueCanvasWidth); 
                const valueX = trueCanvasWidth / 2 - totalValueUnitWidth / 2 + valueTextWidth / 2;
                const unitX = valueX + valueTextWidth / 2 + getResponsiveFontSize(5, trueCanvasWidth) + unitTextWidth / 2;

                ctx.font = `bold ${valueFontSize}px 'Noto Sans TC'`;
                ctx.fillText(valueText, valueX, currentY + valueFontSize * 0.8);
                
                ctx.font = `bold ${unitFontSize}px 'Noto Sans TC'`;
                ctx.fillText(valueUnit, unitX, currentY + valueFontSize * 0.8); 

                currentY += valueFontSize * 1.1; 

                ctx.fillStyle = colors.neutralGrey;
                const descFontSize = getResponsiveFontSize(12, trueCanvasWidth, 450);
                const descLineHeight = descFontSize * 1.5;
                wrapCanvasText(ctx, descriptionText, trueCanvasWidth / 2, currentY, contentWidth * 0.9, descLineHeight, 'center', `${descFontSize}px 'Noto Sans TC'`);
            }
            

            function drawFlowChart(canvasEl, steps, colors) {
                if (!canvasEl) return;
                const ctx = canvasEl.getContext('2d');

                const dpr = window.devicePixelRatio || 1;
                const rect = canvasEl.getBoundingClientRect();
                canvasEl.width = rect.width * dpr;
                canvasEl.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                
                const trueCanvasWidth = rect.width;
                const trueCanvasHeight = rect.height;
                ctx.clearRect(0, 0, trueCanvasWidth, trueCanvasHeight);
                ctx.fillStyle = colors.cardBg;
                ctx.fillRect(0,0,trueCanvasWidth, trueCanvasHeight);


                const isMobile = trueCanvasWidth < 600 || trueCanvasHeight > trueCanvasWidth * 0.6; 
                
                const boxWidth = isMobile ? Math.min(trueCanvasWidth * 0.7, 200) : Math.min(trueCanvasWidth * 0.2, 160);
                const boxHeight = isMobile ? Math.min(trueCanvasHeight * 0.12, 70) : Math.min(trueCanvasHeight * 0.35, 60);
                const arrowSize = Math.min(boxHeight * 0.15, 10);
                const gap = isMobile ? Math.min(trueCanvasHeight * 0.05, 25) : Math.min(trueCanvasWidth * 0.03, 30);
                const totalBoxes = steps.length;
                
                const baseFontSize = getResponsiveFontSize(13, boxWidth, 150);
                const smallFontSize = getResponsiveFontSize(11, boxWidth, 150);
                const textLineHeight = baseFontSize * 1.2;

                let currentX, currentY;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                for (let i = 0; i < totalBoxes; i++) {
                    const step = steps[i];
                    let xPos, yPos;

                    if (isMobile) {
                        xPos = (trueCanvasWidth - boxWidth) / 2;
                        yPos = (i * (boxHeight + gap + arrowSize)) + gap;
                    } else {
                        const totalFlowWidth = totalBoxes * boxWidth + (totalBoxes - 1) * (gap + arrowSize * 1.5);
                        xPos = (trueCanvasWidth - totalFlowWidth) / 2 + i * (boxWidth + gap + arrowSize * 1.5);
                        yPos = (trueCanvasHeight - boxHeight) / 2;
                    }
                    
                    currentX = xPos + boxWidth / 2; 
                    currentY = yPos + boxHeight / 2; 

                    ctx.fillStyle = step.bgColor;
                    ctx.beginPath();
                    const radius = 8;
                    ctx.moveTo(xPos + radius, yPos);
                    ctx.lineTo(xPos + boxWidth - radius, yPos);
                    ctx.quadraticCurveTo(xPos + boxWidth, yPos, xPos + boxWidth, yPos + radius);
                    ctx.lineTo(xPos + boxWidth, yPos + boxHeight - radius);
                    ctx.quadraticCurveTo(xPos + boxWidth, yPos + boxHeight, xPos + boxWidth - radius, yPos + boxHeight);
                    ctx.lineTo(xPos + radius, yPos + boxHeight);
                    ctx.quadraticCurveTo(xPos, yPos + boxHeight, xPos, yPos + boxHeight - radius);
                    ctx.lineTo(xPos, yPos + radius);
                    ctx.quadraticCurveTo(xPos, yPos, xPos + radius, yPos);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = step.textColor;
                    const lines = step.text.split('\n');
                    if (lines.length === 1) {
                        ctx.font = `500 ${baseFontSize}px 'Noto Sans TC'`;
                        ctx.fillText(lines[0], currentX, currentY);
                    } else {
                         ctx.font = `500 ${baseFontSize}px 'Noto Sans TC'`;
                         ctx.fillText(lines[0], currentX, currentY - textLineHeight / 3);
                         ctx.font = `${smallFontSize}px 'Noto Sans TC'`;
                         ctx.fillText(lines[1], currentX, currentY + textLineHeight * 0.66);
                    }

                    if (i < totalBoxes - 1) {
                        ctx.strokeStyle = colors.highlightGold;
                        ctx.fillStyle = colors.highlightGold;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        let arrowStartX, arrowStartY, arrowEndX, arrowEndY;

                        if (isMobile) {
                            arrowStartX = currentX;
                            arrowStartY = yPos + boxHeight;
                            arrowEndX = currentX;
                            arrowEndY = yPos + boxHeight + gap + arrowSize;
                            ctx.moveTo(arrowStartX, arrowStartY);
                            ctx.lineTo(arrowEndX, arrowEndY - arrowSize);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(arrowEndX, arrowEndY);
                            ctx.lineTo(arrowEndX - arrowSize * 0.6, arrowEndY - arrowSize);
                            ctx.lineTo(arrowEndX + arrowSize * 0.6, arrowEndY - arrowSize);
                        } else {
                            arrowStartX = xPos + boxWidth;
                            arrowStartY = currentY;
                            arrowEndX = xPos + boxWidth + gap + arrowSize * 1.5;
                            arrowEndY = currentY;
                            ctx.moveTo(arrowStartX, arrowStartY);
                            ctx.lineTo(arrowEndX - arrowSize, arrowEndY);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(arrowEndX, arrowEndY);
                            ctx.lineTo(arrowEndX - arrowSize, arrowEndY - arrowSize * 0.6);
                            ctx.lineTo(arrowEndX - arrowSize, arrowEndY + arrowSize * 0.6);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            const cumulativeReturnCanvasEl = document.getElementById('cumulativeReturnCanvas');
            const annualizedReturnCanvasEl = document.getElementById('annualizedReturnCanvas');
            const flowChartCanvasEl = document.getElementById('flowChartCanvas');

            const flowChartSteps = [
                { text: "投資者投入資金", bgColor: smartInvestorProPalette.lightAccentBg, textColor: smartInvestorProPalette.primaryBlue },
                { text: "0050 ETF\n追蹤臺灣50指數", bgColor: smartInvestorProPalette.secondaryTeal, textColor: smartInvestorProPalette.white },
                { text: "持有50家龍頭企業", bgColor: smartInvestorProPalette.lightAccentBg, textColor: smartInvestorProPalette.primaryBlue },
                { text: "產生資本利得\n與股息", bgColor: smartInvestorProPalette.secondaryTeal, textColor: smartInvestorProPalette.white }
            ];

            function redrawAllDynamicCanvases() {
                if (cumulativeReturnCanvasEl) {
                    drawBigNumberCanvas(cumulativeReturnCanvasEl, '十年累積總報酬', '242.32', '%', '包含股息再投資的複利效果，展現長期持有增長潛力。', smartInvestorProPalette);
                }
                if (annualizedReturnCanvasEl) {
                    drawBigNumberCanvas(annualizedReturnCanvasEl, '十年年化總報酬', '13.09', '%', '相當於平均每年以此複合成長率增長您的投資。', smartInvestorProPalette);
                }
                if (flowChartCanvasEl) {
                     drawFlowChart(flowChartCanvasEl, flowChartSteps, smartInvestorProPalette);
                }
            }
            
            redrawAllDynamicCanvases();
            window.addEventListener('resize', redrawAllDynamicCanvases);


            const totalReturnData = {
                labels: ['2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022', '2023', '2024', '2025'],
                datasets: [{
                    label: '臺灣50報酬指數 (示意)',
                    data: [11673.87, 13000, 15500, 17000, 21000, 26000, 34000, 33000, 36000, 38000, 39963.72],
                    borderColor: smartInvestorProPalette.primaryBlue,
                    backgroundColor: 'rgba(58, 80, 107, 0.2)', 
                    fill: true,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: smartInvestorProPalette.primaryBlue
                }]
            };

            const totalReturnCtx = document.getElementById('totalReturnChart').getContext('2d');
            new Chart(totalReturnCtx, {
                type: 'line',
                data: totalReturnData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { color: smartInvestorProPalette.textPrimary, font: { size: 10 } },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        },
                        x: {
                            ticks: { color: smartInvestorProPalette.textPrimary, font: { size: 10 } },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: { title: tooltipTitleCallback },
                            backgroundColor: 'rgba(0, 0, 0, 0.75)',
                            titleFont: { size: 13, weight: 'bold' }, bodyFont: { size: 11 }, padding: 8
                        }
                    }
                }
            });

            const dividendData = {
                labels: ['2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022', '2023', '2024'],
                datasets: [
                    {
                        type: 'bar',
                        label: '年度現金股利總額 (元)',
                        data: [2.0, 2.55, 2.9, 3.0, 3.6, 3.75, 3.55, 4.4, 4.9, 3.7],
                        backgroundColor: smartInvestorProPalette.secondaryTealTransparent, // 使用帶透明度的顏色
                        borderColor: smartInvestorProPalette.secondaryTeal, // 邊框可以是不透明的
                        borderWidth: 1,
                        yAxisID: 'y',
                        order: 0 // 長條圖先繪製 (在後)
                    },
                    {
                        type: 'line',
                        label: '年均現金殖利率 (%)',
                        data: [3.03, 2.96, 3.37, 3.75, 3.99, 2.85, 2.40, 3.76, 3.72, 1.88],
                        borderColor: smartInvestorProPalette.highlightGold,
                        backgroundColor: 'transparent', // 折線圖背景通常是透明的
                        tension: 0.3,
                        yAxisID: 'y1',
                        borderWidth: 3, 
                        pointRadius: 6,    
                        pointBackgroundColor: smartInvestorProPalette.highlightGold,
                        pointBorderColor: smartInvestorProPalette.white, 
                        pointBorderWidth: 1.5,   
                        pointHoverRadius: 8, 
                        pointHoverBorderWidth: 2,
                        pointHoverBorderColor: smartInvestorProPalette.white,
                        order: 1 // 折線圖後繪製 (在前)
                    }
                ]
            };
            
            const dividendCtx = document.getElementById('dividendChart').getContext('2d');
            new Chart(dividendCtx, {
                data: dividendData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear', display: true, position: 'left',
                            title: { display: true, text: '現金股利 (元)', color: smartInvestorProPalette.secondaryTeal, font: { weight: '500', size: 11 } },
                            ticks: { color: smartInvestorProPalette.secondaryTeal, font: { size: 10 } },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        },
                        y1: {
                            type: 'linear', display: true, position: 'right',
                            title: { display: true, text: '年均殖利率 (%)', color: smartInvestorProPalette.highlightGold, font: { weight: '500', size: 11 } },
                            ticks: { color: smartInvestorProPalette.highlightGold, font: { size: 10 } },
                            grid: { drawOnChartArea: false },
                        },
                         x: {
                            ticks: { color: smartInvestorProPalette.textPrimary, font: { size: 10 } },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: {
                           position: 'top',
                           labels: { color: smartInvestorProPalette.textPrimary, font: { size: 11 } }
                        },
                        tooltip: {
                            callbacks: {
                                title: tooltipTitleCallback,
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) {
                                        label += parseFloat(context.parsed.y).toFixed(2);
                                        if (context.dataset.yAxisID === 'y') { label += ' 元'; } 
                                        else { label += ' %'; }
                                    }
                                    return label;
                                }
                            },
                            backgroundColor: 'rgba(0, 0, 0, 0.75)',
                            titleFont: { size: 13, weight: 'bold' }, bodyFont: { size: 11 }, padding: 8
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
