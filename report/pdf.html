<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Lite Editor (HTML Version)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.js"></script>

    <style>
        @font-face {
            font-family: 'jf-openhuninn';
            src: url('https://cdn.jsdelivr.net/gh/justfont/open-huninn-font@master/font/jf-openhuninn-1.1.ttf') format('truetype');
            font-display: swap;
        }
        body {
            font-family: "jf-openhuninn", "Noto Sans TC", sans-serif;
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 h-screen flex flex-col overflow-hidden">

    <!-- Toolbar -->
    <div class="h-16 bg-white border-b border-slate-200 shadow-sm flex items-center justify-between px-4 z-40 shrink-0">
        <div class="flex items-center gap-2">
            <div class="bg-indigo-600 text-white p-1.5 rounded-lg shadow-sm">
                <i data-lucide="pen-tool" class="w-5 h-5"></i>
            </div>
            <h1 class="font-bold text-lg text-slate-700 hidden sm:block">PDF Lite Editor</h1>
            <div id="rotation-warning" class="hidden flex items-center text-amber-600 text-xs bg-amber-50 px-2 py-1 rounded-full border border-amber-200 ml-2">
                <i data-lucide="alert-circle" class="w-3 h-3 mr-1"></i>
                <span id="rotation-text">偵測到頁面旋轉</span>
            </div>
        </div>

        <div class="flex items-center gap-3" id="toolbar-actions">
            <label id="upload-btn" class="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 cursor-pointer transition-colors shadow-sm active:scale-95">
                <i data-lucide="upload" class="w-4 h-4"></i>
                <span class="font-medium">上傳 PDF</span>
                <input type="file" id="file-input" accept=".pdf" class="hidden" />
            </label>

            <div id="editor-tools" class="hidden flex items-center gap-2">
                <button onclick="app.addText()" class="p-2 hover:bg-slate-100 rounded-lg flex flex-col items-center group transition-colors">
                    <i data-lucide="type" class="w-5 h-5 group-hover:text-indigo-600"></i>
                    <span class="text-[10px] font-medium">文字</span>
                </button>
                
                <button onclick="app.openSignatureModal()" class="p-2 hover:bg-slate-100 rounded-lg flex flex-col items-center group transition-colors">
                    <i data-lucide="pen-tool" class="w-5 h-5 group-hover:text-indigo-600"></i>
                    <span class="text-[10px] font-medium">簽名</span>
                </button>

                <label class="p-2 hover:bg-slate-100 rounded-lg flex flex-col items-center cursor-pointer group transition-colors">
                    <i data-lucide="image" class="w-5 h-5 group-hover:text-indigo-600"></i>
                    <span class="text-[10px] font-medium">圖片</span>
                    <input type="file" accept="image/*" class="hidden" onchange="app.handleImageUpload(this)" />
                </label>

                <div id="font-controls" class="hidden flex items-center">
                    <div class="h-6 w-[1px] bg-slate-200 mx-1"></div>
                    <div class="flex items-center gap-1 bg-slate-100 rounded-lg p-1">
                        <button onclick="app.changeFontSize(-2)" class="p-1.5 hover:bg-white rounded-md text-slate-600 transition-colors">
                            <i data-lucide="minus" class="w-4 h-4"></i>
                        </button>
                        <span id="font-size-display" class="text-xs font-medium w-8 text-center text-slate-600">16px</span>
                        <button onclick="app.changeFontSize(2)" class="p-1.5 hover:bg-white rounded-md text-slate-600 transition-colors">
                            <i data-lucide="plus" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>

                <div class="h-6 w-[1px] bg-slate-200 mx-1"></div>

                <button onclick="app.downloadPdf()" id="download-btn" class="flex items-center gap-2 px-4 py-2 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 transition-all shadow-sm active:scale-95 font-medium">
                    <i data-lucide="download" class="w-4 h-4"></i>
                    <span class="hidden sm:inline">下載</span>
                </button>
                
                <button onclick="app.reset()" class="p-2 text-slate-400 hover:text-red-500 transition-colors ml-1">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Workspace -->
    <div id="workspace" class="flex-1 overflow-auto bg-slate-100 p-8 flex justify-center relative touch-pan-x touch-pan-y" onclick="app.deselect()">
        <div id="empty-state" class="flex flex-col items-center justify-center text-slate-400 border-2 border-dashed border-slate-300 rounded-xl w-full max-w-2xl h-96 bg-white/50">
            <i data-lucide="upload" class="w-12 h-12 mb-4 opacity-50"></i>
            <p class="text-lg font-medium text-slate-500">請上傳 PDF 文件</p>
            <p class="text-sm mt-2 opacity-60">所有操作皆在瀏覽器完成</p>
        </div>

        <div id="pdf-container" class="relative shadow-xl bg-white hidden origin-top-left transition-transform duration-200 ease-out">
            <canvas id="the-canvas" class="block"></canvas>
            <div id="overlay-layer" class="absolute inset-0"></div>
        </div>
    </div>

    <!-- Signature Modal -->
    <div id="signature-modal" class="hidden fixed inset-0 bg-black/60 z-50 flex items-center justify-center backdrop-blur-sm p-4">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md flex flex-col overflow-hidden animate-in fade-in zoom-in duration-200">
            <div class="flex justify-between items-center p-4 border-b border-slate-100">
                <h3 class="text-lg font-bold text-slate-800">建立簽名</h3>
                <button onclick="app.closeSignatureModal()" class="text-slate-400 hover:text-slate-600 p-1 hover:bg-slate-100 rounded-full">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div class="p-4 bg-slate-50">
                <div class="border border-slate-200 rounded-xl bg-white shadow-inner overflow-hidden relative cursor-crosshair touch-none h-48">
                    <div class="absolute inset-0 pointer-events-none opacity-5" style="background-image: radial-gradient(#64748b 1px, transparent 1px); background-size: 20px 20px;"></div>
                    <canvas id="sign-canvas" width="500" height="250" class="w-full h-full block"></canvas>
                    <div class="absolute bottom-2 right-2 pointer-events-none text-xs text-slate-300 select-none">在此區域簽名</div>
                </div>
            </div>
            <div class="p-4 border-t border-slate-100 flex justify-between bg-white gap-3">
                <button onclick="app.clearSignature()" class="flex-1 px-4 py-2.5 text-slate-600 hover:bg-slate-100 rounded-xl text-sm font-medium transition-colors border border-transparent hover:border-slate-200">清除重寫</button>
                <button onclick="app.saveSignature()" class="flex-1 px-4 py-2.5 bg-indigo-600 text-white rounded-xl hover:bg-indigo-700 text-sm font-bold shadow-lg shadow-indigo-200 transition-all active:scale-95">確認插入</button>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        const CHINESE_FONT_URL = "https://cdn.jsdelivr.net/gh/justfont/open-huninn-font@master/font/jf-openhuninn-1.1.ttf";

        const app = {
            pdfFile: null,
            pdfDoc: null,
            scale: 1.5,
            pageRotation: 0,
            elements: [],
            selectedId: null,
            pdfSize: { width: 0, height: 0 }, // 確保有初始值
            
            dom: {
                fileInput: document.getElementById('file-input'),
                uploadBtn: document.getElementById('upload-btn'),
                editorTools: document.getElementById('editor-tools'),
                emptyState: document.getElementById('empty-state'),
                pdfContainer: document.getElementById('pdf-container'),
                canvas: document.getElementById('the-canvas'),
                overlayLayer: document.getElementById('overlay-layer'),
                fontControls: document.getElementById('font-controls'),
                fontSizeDisplay: document.getElementById('font-size-display'),
                signatureModal: document.getElementById('signature-modal'),
                signCanvas: document.getElementById('sign-canvas'),
                rotationWarning: document.getElementById('rotation-warning'),
                rotationText: document.getElementById('rotation-text'),
                downloadBtn: document.getElementById('download-btn')
            },

            init: function() {
                lucide.createIcons();
                this.dom.fileInput.addEventListener('change', (e) => this.handleFileChange(e));
                this.initSignaturePad();
            },

            handleFileChange: function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const arrayBuffer = event.target.result;
                    this.pdfFile = arrayBuffer;
                    try {
                        const bufferForViewer = arrayBuffer.slice(0);
                        const loadingTask = pdfjsLib.getDocument(bufferForViewer);
                        this.pdfDoc = await loadingTask.promise;
                        this.elements = [];
                        this.selectedId = null;
                        this.renderUIState(true);
                        this.renderPage(1);
                    } catch (error) {
                        console.error(error);
                        alert("無法讀取 PDF 檔案");
                    }
                };
                reader.readAsArrayBuffer(file);
                e.target.value = '';
            },

            renderUIState: function(hasFile) {
                if (hasFile) {
                    this.dom.uploadBtn.classList.add('hidden');
                    this.dom.editorTools.classList.remove('hidden');
                    this.dom.emptyState.classList.add('hidden');
                    this.dom.pdfContainer.classList.remove('hidden');
                } else {
                    this.dom.uploadBtn.classList.remove('hidden');
                    this.dom.editorTools.classList.add('hidden');
                    this.dom.emptyState.classList.remove('hidden');
                    this.dom.pdfContainer.classList.add('hidden');
                    this.dom.overlayLayer.innerHTML = '';
                    this.dom.rotationWarning.classList.add('hidden');
                    const ctx = this.dom.canvas.getContext('2d');
                    ctx.clearRect(0, 0, this.dom.canvas.width, this.dom.canvas.height);
                    this.dom.canvas.style.width = '0px';
                    this.dom.canvas.style.height = '0px';
                }
            },

            reset: function() {
                this.pdfFile = null;
                this.pdfDoc = null;
                this.elements = [];
                this.selectedId = null;
                this.pdfSize = { width: 0, height: 0 };
                this.renderUIState(false);
            },

            renderPage: async function(pageNum) {
                const page = await this.pdfDoc.getPage(pageNum);
                this.pageRotation = page.rotate;

                if (this.pageRotation !== 0) {
                    this.dom.rotationWarning.classList.remove('hidden');
                    this.dom.rotationText.textContent = `偵測到頁面旋轉 (${this.pageRotation}°)，座標可能會有偏差`;
                } else {
                    this.dom.rotationWarning.classList.add('hidden');
                }

                const dpr = window.devicePixelRatio || 1;
                const logicalScale = 1.5;
                this.scale = logicalScale;

                const logicalViewport = page.getViewport({ scale: logicalScale });
                const renderViewport = page.getViewport({ scale: logicalScale * dpr });

                // [修正] 更新 pdfSize 狀態，供拖曳邏輯使用
                this.pdfSize = { width: logicalViewport.width, height: logicalViewport.height };

                const canvas = this.dom.canvas;
                const ctx = canvas.getContext('2d');

                canvas.width = renderViewport.width;
                canvas.height = renderViewport.height;
                canvas.style.width = `${logicalViewport.width}px`;
                canvas.style.height = `${logicalViewport.height}px`;
                
                this.dom.pdfContainer.style.width = `${logicalViewport.width}px`;
                this.dom.pdfContainer.style.height = `${logicalViewport.height}px`;

                await page.render({ canvasContext: ctx, viewport: renderViewport }).promise;
            },

            renderOverlay: function() {
                const container = this.dom.overlayLayer;
                container.innerHTML = '';

                const selectedEl = this.elements.find(e => e.id === this.selectedId);
                if (selectedEl && selectedEl.type === 'text') {
                    this.dom.fontControls.classList.remove('hidden');
                    this.dom.fontSizeDisplay.textContent = `${selectedEl.fontSize}px`;
                } else {
                    this.dom.fontControls.classList.add('hidden');
                }

                this.elements.forEach(el => {
                    const isSelected = el.id === this.selectedId;
                    
                    const elDiv = document.createElement('div');
                    elDiv.className = `absolute group flex flex-col ${isSelected ? 'z-30' : 'z-10 hover:z-20'}`;
                    elDiv.style.left = `${el.x}px`;
                    elDiv.style.top = `${el.y}px`;
                    elDiv.style.width = `${el.width}px`;
                    elDiv.style.height = `${el.height}px`;

                    const contentContainer = document.createElement('div');
                    contentContainer.className = `w-full h-full relative transition-all ${isSelected ? 'ring-2 ring-indigo-500 bg-indigo-50/10' : 'hover:ring-1 hover:ring-slate-300'}`;
                    
                    if (el.type === 'text') {
                        const textarea = document.createElement('textarea');
                        textarea.value = el.content;
                        textarea.className = "w-full h-full bg-transparent resize-none outline-none font-sans overflow-hidden p-1";
                        textarea.style.fontSize = `${el.fontSize}px`;
                        textarea.style.lineHeight = '1.35';
                        textarea.style.padding = '4px';
                        textarea.style.margin = '0';
                        textarea.style.fontFamily = '"jf-openhuninn", "Noto Sans TC", sans-serif';
                        textarea.spellcheck = false;
                        
                        textarea.oninput = (e) => { el.content = e.target.value; };
                        textarea.onmousedown = (e) => { if(isSelected) e.stopPropagation(); }
                        
                        contentContainer.appendChild(textarea);
                    } else {
                        const img = document.createElement('img');
                        img.src = el.content;
                        img.className = "w-full h-full object-contain pointer-events-none";
                        contentContainer.appendChild(img);
                    }

                    if (isSelected) {
                        const delBtn = document.createElement('button');
                        delBtn.innerHTML = '<i data-lucide="trash-2" class="w-3.5 h-3.5"></i>';
                        delBtn.className = "absolute -top-3 -right-3 bg-red-500 text-white p-1 rounded-full shadow-md hover:bg-red-600 transition-transform hover:scale-110 z-40 cursor-pointer flex items-center justify-center";
                        // [修正] 阻止 mousedown 冒泡，防止觸發底下的 selectElement 導致按鈕被銷毀
                        delBtn.onmousedown = (e) => e.stopPropagation();
                        delBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.deleteElement(el.id);
                        };
                        contentContainer.appendChild(delBtn);

                        const dragHandle = document.createElement('div');
                        dragHandle.className = "drag-handle absolute -top-6 left-1/2 -translate-x-1/2 bg-indigo-500 text-white rounded px-2 py-0.5 text-[10px] flex items-center opacity-80 cursor-grab active:cursor-grabbing hover:opacity-100";
                        dragHandle.innerHTML = '<i data-lucide="grip-horizontal" class="w-3 h-3 mr-1"></i> Drag';
                        this.attachDragEvents(dragHandle, el);
                        contentContainer.appendChild(dragHandle);

                        const resizeHandle = document.createElement('div');
                        resizeHandle.className = "resize-handle absolute -bottom-2 -right-2 w-5 h-5 bg-white border-2 border-indigo-500 rounded-full cursor-se-resize z-50 flex items-center justify-center shadow-sm hover:scale-110 transition-transform";
                        resizeHandle.innerHTML = '<div class="w-1.5 h-1.5 bg-indigo-500 rounded-full"></div>';
                        // [修正] 阻止 mousedown 冒泡
                        resizeHandle.onmousedown = (e) => e.stopPropagation();
                        this.attachResizeEvents(resizeHandle, el);
                        contentContainer.appendChild(resizeHandle);
                    }

                    elDiv.onmousedown = (e) => {
                        if (e.target.tagName !== 'BUTTON' && !e.target.classList.contains('resize-handle')) {
                            e.stopPropagation();
                            this.selectElement(el.id);
                        }
                    };

                    elDiv.appendChild(contentContainer);
                    container.appendChild(elDiv);
                });
                
                lucide.createIcons();
            },

            attachDragEvents: function(domElement, dataElement) {
                let startX, startY, initialX, initialY;

                const onMouseMove = (e) => {
                    e.preventDefault();
                    // [修正] 安全獲取 clientX (兼容觸控)
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    const deltaX = clientX - startX;
                    const deltaY = clientY - startY;

                    let newX = initialX + deltaX;
                    let newY = initialY + deltaY;

                    // [修正] 安全讀取 pdfSize，防止 undefined 報錯
                    const containerW = this.pdfSize ? this.pdfSize.width : 0;
                    const containerH = this.pdfSize ? this.pdfSize.height : 0;
                    
                    newX = Math.max(0, Math.min(newX, containerW - dataElement.width));
                    newY = Math.max(0, Math.min(newY, containerH - dataElement.height));

                    dataElement.x = newX;
                    dataElement.y = newY;
                    this.renderOverlay();
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.removeEventListener('touchmove', onMouseMove);
                    document.removeEventListener('touchend', onMouseUp);
                };

                const onMouseDown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    startX = e.touches ? e.touches[0].clientX : e.clientX;
                    startY = e.touches ? e.touches[0].clientY : e.clientY;
                    initialX = dataElement.x;
                    initialY = dataElement.y;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.addEventListener('touchmove', onMouseMove, {passive: false});
                    document.addEventListener('touchend', onMouseUp);
                };

                domElement.addEventListener('mousedown', onMouseDown);
                domElement.addEventListener('touchstart', onMouseDown);
            },

            attachResizeEvents: function(domElement, dataElement) {
                let startX, startY, initialW, initialH;

                const onMouseMove = (e) => {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    const deltaX = clientX - startX;
                    const deltaY = clientY - startY;

                    const newW = Math.max(30, initialW + deltaX);
                    const newH = Math.max(30, initialH + deltaY);

                    dataElement.width = newW;
                    dataElement.height = newH;
                    this.renderOverlay();
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.removeEventListener('touchmove', onMouseMove);
                    document.removeEventListener('touchend', onMouseUp);
                };

                const onMouseDown = (e) => {
                    e.stopPropagation();
                    startX = e.touches ? e.touches[0].clientX : e.clientX;
                    startY = e.touches ? e.touches[0].clientY : e.clientY;
                    initialW = dataElement.width;
                    initialH = dataElement.height;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.addEventListener('touchmove', onMouseMove, {passive: false});
                    document.addEventListener('touchend', onMouseUp);
                };

                domElement.addEventListener('mousedown', onMouseDown);
                domElement.addEventListener('touchstart', onMouseDown);
            },

            addText: function() {
                const id = Date.now();
                this.elements.push({
                    id,
                    type: 'text',
                    x: 50,
                    y: 100,
                    content: '請輸入文字',
                    fontSize: 16,
                    width: 200,
                    height: 50
                });
                this.selectElement(id);
            },

            addImage: function(dataUrl) {
                const id = Date.now();
                const img = new Image();
                img.src = dataUrl;
                img.onload = () => {
                    const aspectRatio = img.width / img.height;
                    this.elements.push({
                        id,
                        type: 'image',
                        x: 100,
                        y: 200,
                        content: dataUrl,
                        width: 60 * aspectRatio,
                        height: 60,
                        aspectRatio: aspectRatio
                    });
                    this.selectElement(id);
                };
            },

            handleImageUpload: function(input) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => this.addImage(e.target.result);
                reader.readAsDataURL(file);
                input.value = '';
            },

            selectElement: function(id) {
                this.selectedId = id;
                this.renderOverlay();
            },

            deselect: function() {
                if (this.selectedId !== null) {
                    this.selectedId = null;
                    this.renderOverlay();
                }
            },

            deleteElement: function(id) {
                this.elements = this.elements.filter(el => el.id !== id);
                this.selectedId = null;
                this.renderOverlay();
            },

            changeFontSize: function(delta) {
                const el = this.elements.find(e => e.id === this.selectedId);
                if (el && el.type === 'text') {
                    el.fontSize = Math.max(10, Math.min(100, el.fontSize + delta));
                    this.renderOverlay();
                }
            },

            openSignatureModal: function() {
                this.dom.signatureModal.classList.remove('hidden');
                const ctx = this.dom.signCanvas.getContext('2d');
                ctx.clearRect(0, 0, 500, 250);
            },
            closeSignatureModal: function() {
                this.dom.signatureModal.classList.add('hidden');
            },
            initSignaturePad: function() {
                const canvas = this.dom.signCanvas;
                const ctx = canvas.getContext('2d');
                let isDrawing = false;

                const getPos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    return { x: clientX - rect.left, y: clientY - rect.top };
                };

                const start = (e) => {
                    e.preventDefault();
                    isDrawing = true;
                    const pos = getPos(e);
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = '#000';
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                };

                const move = (e) => {
                    if (!isDrawing) return;
                    e.preventDefault();
                    const pos = getPos(e);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                };

                const end = () => { isDrawing = false; };

                canvas.addEventListener('mousedown', start);
                canvas.addEventListener('mousemove', move);
                canvas.addEventListener('mouseup', end);
                canvas.addEventListener('touchstart', start);
                canvas.addEventListener('touchmove', move);
                canvas.addEventListener('touchend', end);
            },
            clearSignature: function() {
                const ctx = this.dom.signCanvas.getContext('2d');
                ctx.clearRect(0, 0, 500, 250);
            },
            saveSignature: function() {
                const dataUrl = this.dom.signCanvas.toDataURL('image/png');
                this.addImage(dataUrl);
                this.closeSignatureModal();
            },

            downloadPdf: async function() {
                if (!this.pdfFile) return;
                
                const btn = this.dom.downloadBtn;
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> 處理中';
                btn.disabled = true;
                lucide.createIcons();

                try {
                    const { PDFDocument, rgb, StandardFonts } = PDFLib;
                    const pdfDoc = await PDFDocument.load(this.pdfFile);
                    pdfDoc.registerFontkit(fontkit);

                    const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                    let customFont = helveticaFont;
                    try {
                        const fontBytes = await fetch(CHINESE_FONT_URL).then(res => {
                            if (!res.ok) throw new Error("Font fetch failed");
                            return res.arrayBuffer();
                        });
                        customFont = await pdfDoc.embedFont(fontBytes);
                    } catch (e) {
                        console.warn("Font fallback", e);
                    }

                    const firstPage = pdfDoc.getPages()[0];
                    const { width, height } = firstPage.getSize();
                    const rotationAngle = firstPage.getRotation().angle;

                    let pdfVisualWidth = width;
                    let pdfVisualHeight = height;
                    if (rotationAngle === 90 || rotationAngle === 270) {
                        pdfVisualWidth = height;
                        pdfVisualHeight = width;
                    }

                    const canvasWidth = this.pdfSize.width;
                    const canvasHeight = this.pdfSize.height;
                    const scaleX = canvasWidth > 0 ? pdfVisualWidth / canvasWidth : 1;
                    const scaleY = canvasHeight > 0 ? pdfVisualHeight / canvasHeight : 1;

                    for (const el of this.elements) {
                        if (el.type === 'text') {
                            const fontToUse = customFont;
                            const fontSizePdf = el.fontSize * scaleX;
                            const PADDING = 4;
                            const PADDING_X_OFFSET = 1;
                            const LINE_HEIGHT_FACTOR = 1.35;

                            const availableWidthPdf = (el.width * scaleX) - (PADDING * 2 * scaleX);
                            const lines = this.breakTextIntoLines(el.content, fontSizePdf, fontToUse, availableWidthPdf);
                            const wrappedText = lines.join('\n');

                            const visualX = (el.x + PADDING + PADDING_X_OFFSET) * scaleX;
                            const BASELINE_OFFSET = fontSizePdf * 1.05;
                            const visualY = (el.y + PADDING) * scaleY + BASELINE_OFFSET;

                            let pdfX, pdfY;
                            if (rotationAngle === 0) {
                                pdfX = visualX;
                                pdfY = height - visualY;
                            } else if (rotationAngle === 90) {
                                pdfX = visualY;
                                pdfY = height - (width - visualX);
                                pdfX = visualX;
                                pdfY = height - visualY;
                            } else {
                                pdfX = visualX;
                                pdfY = height - visualY;
                            }

                            firstPage.drawText(wrappedText, {
                                x: pdfX,
                                y: pdfY,
                                size: fontSizePdf,
                                font: fontToUse,
                                color: rgb(0, 0, 0),
                                lineHeight: fontSizePdf * LINE_HEIGHT_FACTOR,
                            });

                        } else if (el.type === 'image') {
                            let pngImage;
                            if (el.content.startsWith('data:image/jpeg') || el.content.startsWith('data:image/jpg')) {
                                pngImage = await pdfDoc.embedJpg(el.content);
                            } else {
                                pngImage = await pdfDoc.embedPng(el.content);
                            }

                            const imgHeightPdf = el.height * scaleY;
                            const visualX = el.x * scaleX;
                            const visualY = el.y * scaleY;
                            
                            const pdfX = visualX;
                            const pdfY = height - visualY - imgHeightPdf;

                            firstPage.drawImage(pngImage, {
                                x: pdfX,
                                y: pdfY,
                                width: el.width * scaleX,
                                height: imgHeightPdf,
                            });
                        }
                    }

                    const pdfBytes = await pdfDoc.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `signed_document_${Date.now()}.pdf`;
                    link.click();

                } catch (err) {
                    console.error(err);
                    alert("儲存失敗: " + err.message);
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    lucide.createIcons();
                }
            },

            breakTextIntoLines: function(text, size, font, maxWidth) {
                const paragraphs = text.split('\n');
                let lines = [];
                for (const paragraph of paragraphs) {
                    let currentLine = '';
                    for (let i = 0; i < paragraph.length; i++) {
                        const char = paragraph[i];
                        const testLine = currentLine + char;
                        const width = font.widthOfTextAtSize(testLine, size);
                        if (width > maxWidth) {
                            lines.push(currentLine);
                            currentLine = char;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    if (currentLine) lines.push(currentLine);
                }
                return lines;
            }
        };

        window.onload = () => app.init();

    </script>
</body>
</html>
