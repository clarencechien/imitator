<!DOCTYPE html>
<html lang="zh-Hant" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12-Factor Agent 中文教學</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        :root {
            --sidebar-width: 18rem;
        }
        html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #0f172a; /* bg-slate-900 */
        }
        .sidebar-link.active {
            background-color: #1e40af; /* dark blue */
            color: #ffffff;
        }
        .content-section h2 {
            font-size: 2.25rem;
            font-weight: 700;
            letter-spacing: -0.025em;
            background: linear-gradient(to right, #60a5fa, #34d399);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #334155; /* gray-700 */
            margin-top: 3.5rem; /* Increased spacing */
            margin-bottom: 2.5rem; /* Increased spacing */
        }
        .content-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f3f4f6; /* gray-100 */
            margin-top: 3.5rem; /* Increased spacing */
            margin-bottom: 1.5rem; /* Increased spacing */
        }
        /* Adjusted text color and spacing for better readability */
        .content-section p, 
        .content-section ul, 
        .content-section ol {
            line-height: 1.8;
            color: #e5e7eb; /* Brighter text color (gray-200) */
            margin-bottom: 1.75rem; /* Increased spacing */
        }
        .content-section li {
            margin-bottom: 0.75rem;
        }
        .content-section ul li {
            list-style-type: none;
            position: relative;
            padding-left: 1.75rem;
        }
        .content-section ul li::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: #3b82f6; /* blue-500 */
            font-weight: bold;
        }
        .content-section ol {
            list-style-type: decimal;
            margin-left: 1.5rem;
        }
        .content-section code {
            background-color: #111827; /* gray-900 */
            color: #93c5fd; /* blue-300 */
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.9em;
        }
        .content-section pre {
            background-color: #030712; /* gray-950 */
            border: 1px solid #374151; /* gray-700 */
            padding: 1.25rem;
            border-radius: 0.75rem;
            overflow-x: auto;
            margin: 2.5rem 0;
        }
        .content-section blockquote {
            border-left: 4px solid #3b82f6; /* blue-500 */
            padding-left: 1.5rem;
            margin: 3rem 0; /* Increased spacing */
            color: #e5e7eb; /* gray-200 */
            background-color: #1f2937; /* gray-800 */
            padding-top: 1rem;
            padding-bottom: 1rem;
            border-radius: 0 0.5rem 0.5rem 0;
        }
        .content-section img {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            margin: 3rem auto; /* Increased spacing */
            border: 1px solid #374151; /* gray-700 */
            background-color: #111827;
            display: block;
        }
        .video-container {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            max-width: 100%;
            border-radius: 0.75rem;
            border: 1px solid #374151;
            margin: 2.5rem 0;
        }
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300">

    <div class="flex min-h-screen">
        <!-- Sidebar -->
        <aside id="sidebar" class="w-[var(--sidebar-width)] bg-slate-900/70 backdrop-blur-lg border-r border-slate-700 p-6 fixed h-full overflow-y-auto transition-transform -translate-x-full lg:translate-x-0 z-20">
            <div class="flex items-center gap-3 mb-8">
                <i class="ph-bold ph-brain text-3xl text-blue-400"></i>
                <h1 class="text-xl font-bold text-white">12-Factor Agent</h1>
            </div>
            <nav id="sidebar-nav" class="space-y-1">
                <!-- Links will be injected by JavaScript -->
            </nav>
        </aside>

        <!-- Main content -->
        <main class="flex-1 lg:ml-[var(--sidebar-width)] p-4 sm:p-6 lg:p-12">
            <!-- Adjusted max-width for better readability -->
            <div id="main-content" class="max-w-4xl mx-auto bg-slate-800/50 backdrop-blur-sm border border-slate-700 p-6 sm:p-8 lg:p-12 rounded-2xl">
                <!-- Content will be injected by JavaScript -->
            </div>
        </main>
        
        <!-- Mobile Header & Menu Button -->
        <header class="lg:hidden fixed top-0 left-0 right-0 bg-slate-900/80 backdrop-blur-md shadow-lg z-10 border-b border-slate-700">
            <div class="flex justify-between items-center p-4">
                <div class="flex items-center gap-3">
                    <i class="ph-bold ph-brain text-2xl text-blue-400"></i>
                    <h1 class="text-lg font-bold text-white">12-Factor Agent</h1>
                </div>
                <button id="menu-toggle" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-slate-500">
                     <i class="ph ph-list text-2xl text-white"></i>
                </button>
            </div>
        </header>
        <div id="overlay" class="fixed inset-0 bg-black/50 z-10 hidden lg:hidden"></div>

    </div>

    <script>
        const content = {
            "intro": {
                "title": "簡介與軟體發展簡史",
                "icon": "ph-rocket-launch",
                "html": `
                    <div class="content-section">
                        <h2>簡介：為 AI Agent 建立可靠的方法論</h2>
                        <p>「12-Factor App」方法論在過去十年徹底改變了我們建構和部署網路應用程式的方式。然而，隨著大型語言模型（LLM）和 AI Agent 的興起，我們正面臨著新的挑戰。</p>
                        <p>AI Agent 的行為具有不確定性，這使得傳統的軟體工程實踐變得困難。這個專案提出的「12-Factor Agent」旨在借鏡「12-Factor App」的成功經驗，為建構、部署和維護可靠、可擴展且可維護的 AI Agent 提供一套指導原則。</p>
                        
                        <h3>軟體發展的演進</h3>
                        <p>軟體開發從單體應用程式，演進到由 Airflow、Kubernetes 等工具編排的有向無環圖（DAG），再到機器學習（ML）管線。現在，Agent 的出現引入了一種新的典範：由 LLM 驅動的迴圈（loop）取代了傳統 DAG 中的節點。這種 Agent 迴圈能夠根據上下文動態地決定下一步行動，但也帶來了可預測性和狀態管理的複雜性。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/027-agent-loop-dag.png" alt="Agent DAG 示意圖">
                        
                        <h3>核心挑戰</h3>
                        <p>我們面臨的核心挑戰是如何在 Agent 的靈活性和傳統軟體工程的嚴謹性之間找到平衡。這十二個因子就是為了解決這個問題而提出的。</p>

                        <h3>背景影片與摘要</h3>
                        <p>以下影片由「12-Factor Agent」的原作者 Dex Horthy 所演講，詳細闡述了這些原則背後的動機和觀察。觀看此影片將有助於更深入地理解為何我們需要一套新的方法論來建構可靠的 LLM 應用。</p>
                        <div class="video-container">
                           <iframe src="https://www.youtube.com/embed/8kMaTybvDUw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading="lazy"></iframe>
                        </div>
                        <h4>影片摘要：</h4>
                        <p>在這場演講中，Dex Horthy 探討了在建構 AI 代理時所遇到的普遍挑戰，特別是當品質達到一定瓶頸後難以突破的問題。基於與上百位開發者的交流，他總結出幾個關鍵模式：</p>
                        <ul>
                            <li>多數生產環境的「代理」更像是傳統軟體，而非完全自主的代理。</li>
                            <li>成功的關鍵在於應用軟體工程的基本原則，並將大型問題模組化。</li>
                            <li>開發者需要完全掌控代理的<strong>提示 (Prompts)</strong>、<strong>上下文建構 (Context Building)</strong> 和<strong>控制流 (Control Flow)</strong>，而不是依賴框架的黑箱作業。</li>
                            <li>將人類的互動視為一種工具呼叫、妥善處理錯誤、並傾向於建構小型、專注的「微代理」，是提升系統可靠性的重要策略。</li>
                        </ul>
                        <p>總結來說，Horthy 強調代理本身就是軟體，應遵循嚴謹的軟體工程實踐。LLM 作為一個無狀態函數，其可靠性高度依賴於開發者如何精確地提供上下文和引導其行為。</p>
                    </div>
                `
            },
            "factor-1": {
                "title": "I. 自然語言到工具呼叫",
                "icon": "ph-chat-circle-dots",
                "html": `
                    <div class="content-section">
                        <h2>第一因子：將自然語言轉換為結構化的工具呼叫</h2>
                        <p>這是 Agent 的核心魔法所在。Agent 的根本任務是將模糊的人類意圖（自然語言）轉譯成精確、可執行的機器指令（結構化的工具呼叫）。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/110-natural-language-tool-calls.png" alt="自然語言到工具呼叫示意圖">
                        
                        <h3>核心理念：意圖與執行的分離</h3>
                        <p>傳統程式設計中，我們必須明確寫下每一步的邏輯。而 Agent 典範的美妙之處在於，我們只需要描述「做什麼」（What），而由 LLM 來決定「如何做」（How），也就是選擇並組合正確的工具來達成目標。</p>
                        
                        <h3>生活化譬喻：聰明的專案經理</h3>
                        <blockquote>您可以把 Agent 想像成一位非常聰明的專案經理。您對他說：「幫我規劃一趟去東京的五天四夜旅行。」這是一個高層次的自然語言指令。這位經理會將其分解成一系列具體的、可執行的任務，就像工具呼叫一樣：
                            <ul>
                                <li><code>search_flights(destination="Tokyo", departure_date="2025-10-10", return_date="2025-10-15")</code></li>
                                <li><code>find_hotels(city="Tokyo", check_in="2025-10-10", nights=5, stars=4)</code></li>
                                <li><code>get_local_attractions(city="Tokyo", interests=["food", "history"])</code></li>
                            </ul>
                        </blockquote>
                        
                        <h3>為何重要？</h3>
                        <ul>
                            <li><strong>可靠性：</strong> 將模糊的語言轉換為結構化的 JSON 輸出，是確保 Agent 行為可預測的第一步。</li>
                            <li><strong>關注點分離：</strong> 您可以專注於設計強大的工具（APIs），而讓 LLM 專注於理解使用者意圖並調度這些工具。</li>
                        </ul>
                    </div>
                `
            },
            "factor-2": {
                "title": "II. 掌握你的提示",
                "icon": "ph-scroll",
                "html": `
                    <div class="content-section">
                        <h2>第二因子：程式碼與提示（Prompt）的分離與版本控制</h2>
                        <p>如果說工具是 Agent 的四肢，那麼提示（Prompt）就是 Agent 的大腦和靈魂。它定義了 Agent 的行為、個性、思考模式和決策邏輯。因此，我們必須像對待最重要的程式碼一樣，用嚴謹的工程方法來管理提示。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/120-own-your-prompts.png" alt="掌握你的提示示意圖">
                        
                        <h3>核心理念：提示即程式碼 (Prompt as Code)</h3>
                        <p>將提示從應用程式邏輯中抽離出來，作為獨立的資產進行管理。這不僅僅是為了整潔，更是為了敏捷性和可維護性。</p>

                        <h3>具體作法</h3>
                        <ul>
                            <li><strong>版本控制：</strong> 將提示儲存在 Git 等版本控制系統中。每一次的修改都應該有紀錄，方便追蹤、比較效果和必要時回滾。</li>
                            <li><strong>獨立檔案：</strong> 將提示儲存在獨立的檔案中（如 <code>.txt</code>, <code>.md</code> 或專門的模板語言檔案），而不是以字串形式硬編碼在程式碼裡。</li>
                            <li><strong>模板化與變數：</strong> 使用模板引擎（如 Jinja, Handlebars）來建構提示，這樣可以動態地將對話歷史、工具定義等上下文資訊安全地注入到提示中。</li>
                        </ul>

                        <h3>常見陷阱</h3>
                        <blockquote>最常見的錯誤就是將冗長的提示字串直接寫在 Python 或 TypeScript 程式碼中。這會導致：
                            <ul>
                               <li>修改提示需要重新部署整個應用。</li>
                               <li>非技術人員（如產品經理）難以參與提示的優化。</li>
                               <li>難以對提示進行 A/B 測試。</li>
                            </ul>
                        </blockquote>
                    </div>
                `
            },
             "factor-3": {
                "title": "III. 掌握你的上下文視窗",
                "icon": "ph-books",
                "html": `
                    <div class="content-section">
                        <h2>第三因子：明確地建構與管理上下文</h2>
                        <p>上下文視窗（Context Window）是 LLM 在進行單次推理時能夠「看到」的所有資訊，是它的「工作記憶」。這個記憶是有限且昂貴的。Agent 的輸出品質直接取決於我們放入這個視窗中的資訊品質。因此，我們必須親手、明確地控制上下文的建構過程。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/130-own-your-context-building.png" alt="掌握你的上下文視窗示意圖">

                        <h3>核心理念：上下文即 API 請求</h3>
                        <p>每一次對 LLM 的呼叫，其上下文都應該由您的程式碼在當下明確建構出來。絕對不要依賴框架在背後隱性地、自動地為您管理對話歷史或添加資訊。</p>

                        <h3>生活化譬喻：向一位失憶的專家求助</h3>
                        <blockquote>想像一下，您正在與一位非常有才華但沒有長期記憶的專家合作。每次您問他問題時，都必須提供解決該問題所需的所有背景資訊：
                            <ul>
                                <li><strong>你是誰：</strong> 系統提示 (System Prompt)</li>
                                <li><strong>我們剛剛聊了什麼：</strong> 對話歷史 (Chat History)</li>
                                <li><strong>你可以使用的工具：</strong> 可用的工具定義 (Tool Definitions)</li>
                                <li><strong>相關參考資料：</strong> 從向量資料庫中檢索的文件 (RAG results)</li>
                            </ul>
                            您給的資料越精確、越相關，專家的回答就越好。如果您給了一堆無關的廢話，只會讓他感到困惑。這就是「上下文工程」（Context Engineering）。
                        </blockquote>
                        
                        <h3>常見陷阱</h3>
                        <p>許多框架為了「方便」會自動處理對話歷史。這在初期很美好，但很快就會讓您失去對系統行為的控制。當 Agent 開始出現非預期行為時，您會很難除錯，因為您不確定它到底「看到」了什麼資訊。</p>
                    </div>
                `
            },
            "factor-4": {
                "title": "IV. 工具即結構化輸出",
                "icon": "ph-wrench",
                "html": `
                    <div class="content-section">
                        <h2>第四因子：將工具定義為 LLM 的結構化輸出</h2>
                        <p>這個原則徹底改變了我們與 LLM 互動的方式。我們不應該讓 LLM 回傳一段自然語言，然後我們用脆弱的字串解析（Parsing）去猜測它想做什麼。相反地，我們應該利用現代 LLM 的原生「工具使用」（Tool Use）或「函式呼叫」（Function Calling）能力，強制它以我們預先定義好的、嚴格的 JSON 格式回傳結果。</p>
                         <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/140-tools-are-just-structured-outputs.png" alt="工具即結構化輸出示意圖">

                        <h3>核心理念：從猜測意圖到宣告意圖</h3>
                        <p>這是一個典範轉移：從「LLM，請告訴我該怎麼做」轉變為「LLM，請告訴我要呼叫哪一個工具，並提供符合這個 JSON 格式的參數」。</p>

                        <h3>具體作法</h3>
                        <p>在您的程式碼中，您會定義工具的規格，通常是一個 JSON Schema。</p>
                        <pre><code class="language-json">
// 定義一個「傳送郵件」工具的規格
{
  "name": "send_email",
  "description": "傳送一封電子郵件給收件人",
  "parameters": {
    "type": "object",
    "properties": {
      "recipient": {
        "type": "string",
        "description": "收件人的電子郵件地址"
      },
      "subject": {
        "type": "string",
        "description": "郵件主旨"
      },
      "body": {
        "type": "string",
        "description": "郵件內文"
      }
    },
    "required": ["recipient", "subject", "body"]
  }
}
                        </code></pre>
                        <p>當 LLM 決定要傳送郵件時，它就必須回傳一個像下面這樣、100% 符合規格的 JSON 物件，否則 API 就會報錯。這讓您的後端程式碼可以非常可靠地處理 Agent 的意圖。</p>

                        <h3>為何重要？</h3>
                        <blockquote>這可能是提升 Agent 可靠性最重要的一個步驟。它消除了所有因為解析自然語言而產生的模糊性和不確定性，讓 Agent 的行為變得像傳統 API 呼叫一樣清晰、可預測。</blockquote>
                    </div>
                `
            },
            "factor-5": {
                "title": "V. 統一執行狀態",
                "icon": "ph-stack",
                "html": `
                    <div class="content-section">
                        <h2>第五因子：將所有狀態統一到對話歷史中</h2>
                        <p>Agent 的狀態管理是開發中最棘手的問題之一。這個原則提出了一個極簡但強大的解決方案：不要在程式碼的各個角落分散地儲存狀態。將每一次的互動——無論是使用者的輸入、Agent 的思考過程、工具的呼叫、還是工具的回傳結果——都當作一個事件，按照時間順序追加到一個統一的「對話歷史」列表中。</p>
                         <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/155-unify-state-animation.gif" alt="統一執行狀態動畫">
                         
                        <h3>核心理念：執行即日誌 (Execution as a Log)</h3>
                        <p>Agent 的完整執行過程，就是這份對話歷史。這份歷史成為了系統中唯一的、不可變的「事實來源」（Single Source of Truth）。</p>

                        <h3>生活化譬喻：飛機的黑盒子</h3>
                        <blockquote>這份對話歷史就像是飛機的飛行紀錄器（黑盒子）。它忠實地記錄了飛行過程中的每一個關鍵事件。如果飛機（Agent）出現了問題，我們不需要去猜測，只需要回放這份紀錄，就能精確地知道在每一個時間點上，系統的狀態是什麼，發生了什麼事。這對於除錯和分析至關重要。</blockquote>
                        
                        <h3>為何重要？</h3>
                         <ul>
                            <li><strong>可除錯性：</strong> 任何失敗的執行緒都可以被完美地重現（Replay），因為所有的狀態都在那份歷史紀錄裡。</li>
                            <li><strong>無狀態邏輯：</strong> 您的 Agent 核心邏輯可以變得無狀態，因為它每次都從傳入的歷史紀錄中獲取所有需要的資訊。</li>
                            <li><strong>持久化：</strong> 將 Agent 的執行狀態保存下來變得非常簡單——只需要將這份對話歷史列表序列化（例如，存成 JSON）並儲存到資料庫即可。</li>
                        </ul>
                    </div>
                `
            },
            "factor-6": {
                "title": "VI. 啟動、暫停、恢復",
                "icon": "ph-play-pause",
                "html": `
                    <div class="content-section">
                        <h2>第六因子：透過簡單的 API 介面控制 Agent 的生命週期</h2>
                        <p>許多 Agent 任務不是瞬間完成的。它們可能需要執行好幾個小時，或者在過程中需要等待人類的輸入。因此，我們不能將 Agent 視為一個單一的、同步的函式呼叫。我們需要一個能夠管理其生命週期的標準介面。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/165-pause-resume-animation.gif" alt="啟動、暫停、恢復動畫">

                        <h3>核心理念：Agent 即狀態機</h3>
                        <p>Agent 的執行可以被模型化為一個可以被外部控制的狀態機。這三個核心 API 就是控制狀態轉換的標準方法。</p>
                        
                        <h3>API 設計與範例</h3>
                        <ul>
                            <li><code><strong>Launch(input) -> State</strong></code>: <strong>啟動</strong>一個新的執行緒。例如，當使用者提交一個新請求時呼叫。它會回傳這個執行緒的初始狀態（通常包含第一則使用者訊息）。</li>
                            <li><code><strong>Pause(State) -> State</strong></code>: <strong>暫停</strong>執行。這通常不是一個直接呼叫的 API，而是 Agent 在等待某個長時間執行的工具（如人類的回饋）時，自動進入的狀態。</li>
                            <li><code><strong>Resume(State) -> State</strong></code>: <strong>恢復</strong>一個已暫停的執行緒。例如，當人類提供了回饋，或某個非同步的工具完成了它的工作時，我們將結果加入狀態中，然後呼叫此 API 讓 Agent 繼續下一步。</li>
                        </ul>
                        
                        <h3>為何重要？</h3>
                        <blockquote>這個模型讓 Agent 的執行變得非同步且可中斷。它使得需要長時間運行或有人類介入的複雜工作流程成為可能。例如，一個「部署應用程式」的 Agent 可能會呼叫一個需要十分鐘才能完成的 CI/CD 工具。在這十分鐘內，Agent 會處於「暫停」狀態，直到工具完成並回傳結果，然後再「恢復」執行。</blockquote>
                        <p>這一切之所以可行，都建立在因子五的基礎上——因為所有的狀態都被封裝在那個可以被傳遞和儲存的 <code>State</code> 物件中。</p>
                    </div>
                `
            },
            "factor-7": {
                "title": "VII. 透過工具與人互動",
                "icon": "ph-user-sound",
                "html": `
                    <div class="content-section">
                        <h2>第七因子：將人類視為 Agent 可以呼叫的一種工具</h2>
                        <p>當 Agent 遇到無法獨自解決的問題，或者需要進行一個高風險操作時，它應該能夠請求人類的協助。這個原則提出了一個優雅的解決方案：不要為「人機互動」設計一套特殊的邏輯，而是將「向人類提問」也定義成一個標準的工具。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/170-contact-humans-with-tools.png" alt="透過工具與人互動示意圖">
                        
                        <h3>核心理念：人機協作的統一介面</h3>
                        <p>在 Agent 的世界裡，呼叫一個天氣 API 和請求一個人類批准刪除資料庫，應該遵循完全相同的模式：都是一次工具呼叫。</p>
                        
                        <h3>實踐範例：請求批准</h3>
                        <p>我們可以定義一個名為 <code>request_human_approval</code> 的工具，它的參數可能是一個需要人類確認的問題。</p>
                        <pre><code class="language-json">
// LLM 決定呼叫這個工具
{
  "tool_name": "request_human_approval",
  "parameters": {
    "question": "我即將要刪除正式環境的 user_database，請確認是否繼續？",
    "options": ["確認刪除", "取消"]
  }
}
                        </code></pre>
                        <p>當您的程式碼偵測到這個工具呼叫時，它不會真的去執行一段程式，而是：</p>
                        <ol>
                            <li>透過 Slack、Email 或 Web UI 將這個問題發送給相關人員。</li>
                            <li>將 Agent 的執行緒暫停（因子六），等待人類的回應。</li>
                            <li>當人類點擊「確認刪除」按鈕後，您的系統會將 <code>{"approved": true}</code> 作為工具的結果。</li>
                            <li>將這個結果加入對話歷史，並恢復（因子六）Agent 的執行。</li>
                        </ol>
                        
                        <h3>為何重要？</h3>
                        <blockquote>這種模式讓「人機迴圈」（Human-in-the-loop）成為系統的一等公民，極大地增強了 Agent 的安全性、可靠性和處理複雜模糊情境的能力。</blockquote>
                    </div>
                `
            },
            "factor-8": {
                "title": "VIII. 掌握你的控制流",
                "icon": "ph-git-branch",
                "html": `
                    <div class="content-section">
                        <h2>第八因子：由你的程式碼（而非框架）來決定控制流</h2>
                        <p>許多 Agent 框架為了追求「魔法般」的體驗，會將核心的執行迴圈（control flow）隱藏起來。您只需要定義工具和提示，框架就會自動地在背景執行一個 \`while\` 迴圈。這個原則強烈反對這種做法，主張控制流必須由開發者自己的應用程式程式碼明確地擁有和管理。</p>
                         <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/180-control-flow.png" alt="掌握你的控制流示意圖">

                        <h3>核心理念：拒絕黑箱，擁抱透明</h3>
                        <p>LLM 應該只負責決定迴圈內「單一步」的行為（例如，下一步要呼叫哪個工具），而整個迴圈的啟動、持續、終止條件以及例外處理，都應該由您的確定性（deterministic）程式碼來控制。</p>

                        <h3>生活化譬喻：您是司機，LLM 是導航系統</h3>
                        <blockquote>框架的黑箱就像是自動駕駛。它很神奇，但當它出錯時，您很難介入。而掌握控制流就像是您自己開車，但使用 Google Maps 來導航。
                            <ul>
                                <li><strong>LLM (導航系統)：</strong> 在每個路口告訴您「下一步，向右轉」。</li>
                                <li><strong>您的程式碼 (司機)：</strong> 實際控制方向盤和油門。如果看到前方有障礙物，即使導航說直走，您也會踩剎車。您也可以決定今天不想去導航的目的地，而提前結束行程。</li>
                            </ul>
                            您掌握著最終的控制權，只是將每一步的「決策」外包給了專家（LLM）。
                        </blockquote>

                        <h3>為何重要？</h3>
                        <p>當您自己編寫執行迴圈時，您就擁有了完全的控制權和透明度。您可以輕鬆地加入日誌紀錄、設定最大執行次數、根據特定工具的結果來改變流程，或是在 Agent 卡住時進行干預。這對於建構一個可靠、可維護的生產級系統至關重要。</p>
                    </div>
                `
            },
            "factor-9": {
                "title": "IX. 緊湊的錯誤訊息",
                "icon": "ph-bug",
                "html": `
                    <div class="content-section">
                        <h2>第九因子：將錯誤視為上下文的一部分並使其緊湊</h2>
                        <p>在與外部世界互動時，失敗是不可避免的——API 可能會超時，網路可能會中斷，參數可能會錯誤。一個強健的 Agent 不應該在遇到錯誤時就崩潰，而應該有能力理解錯誤並嘗試自我修復。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/195-factor-9-errors.gif" alt="緊湊的錯誤訊息動畫">

                        <h3>核心理念：對 LLM 友善的錯誤回饋</h3>
                        <p>關鍵在於，我們回傳給 LLM 的錯誤訊息，不應該是給開發者看的完整錯誤堆疊（Stack Trace）。那對 LLM 來說只是無意義的雜訊，而且會嚴重浪費寶貴的上下文空間。我們需要將錯誤「翻譯」成對 LLM 來說簡潔、清晰且可操作的資訊。</p>
                        
                        <h3>錯誤處理的最佳實踐</h3>
                        <ol>
                            <li><strong>捕獲例外：</strong> 在您的工具執行程式碼中，使用 <code>try...catch</code> 區塊來捕獲所有可能的例外。</li>
                            <li><strong>紀錄完整日誌：</strong> 將完整的、詳細的錯誤堆疊和相關資訊記錄到您的日誌系統（如 Datadog, Sentry）中，供開發人員事後分析。</li>
                            <li><strong>生成緊湊摘要：</strong> 從捕獲的錯誤中，提煉出一個簡短的摘要。</li>
                            <li><strong>回傳給 Agent：</strong> 將這個摘要作為工具的執行結果，回傳給 Agent，並添加到對話歷史中。</li>
                        </ol>

                        <h3>範例：好的錯誤 vs. 壞的錯誤</h3>
                        <blockquote>
                            <p><strong>壞的回饋 (對 LLM 無用):</strong></p>
                            <pre><code>(node:12345) UnhandledPromiseRejectionWarning: Error: Request failed with status code 404
at createError (/app/node_modules/axios/lib/core/createError.js:16:15)
at settle (/app/node_modules/axios/lib/helpers/settle.js:17:12)
... 50 more lines ...</code></pre>
                            
                            <p><strong>好的回饋 (對 LLM 有用):</strong></p>
                            <pre><code>{"status": "error", "error_type": "API_NOT_FOUND", "message": "呼叫 getUser(userId='user-5678') 失敗，伺服器回應 404 Not Found，可能是 userId 不存在。"}</code></pre>
                        </blockquote>
                        <p>有了這樣清晰的回饋，LLM 在下一步的推理中，就很有可能嘗試用一個不同的 <code>userId</code> 來重新呼叫工具，從而實現自我修正。</p>
                    </div>
                `
            },
            "factor-10": {
                "title": "X. 小型、專注的 Agent",
                "icon": "ph-puzzle-piece",
                "html": `
                    <div class="content-section">
                        <h2>第十因子：傾向於組合多個小型、專注的 Agent</h2>
                        <p>當面對一個複雜的任務時，我們的直覺可能是建立一個無所不能的「超級 Agent」。然而，這種單體式（Monolithic）的 Agent 非常難以建構、測試和維護。這個原則借鑒了軟體架構中的「微服務」思想，主張我們應該建立多個小型的、只負責一項單一職責的 Agent。</p>
                         <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/1a5-agent-scope-grow.gif" alt="Agent 範疇擴張問題動畫">
                         
                        <h3>核心理念：單一職責原則 (Single Responsibility Principle)</h3>
                        <p>每個 Agent 都應該只做一件事，並把它做好。這使得它們的提示更簡單、工具集更小、行為也更容易預測。</p>

                        <h3>生活化譬喻：廚房團隊 vs. 全能廚師</h3>
                        <blockquote>
                            <p>一個大型餐廳的廚房不會只有一位試圖做所有事情的廚師。它有一個專業分工的團隊：</p>
                            <ul>
                                <li><strong>採購 Agent：</strong> 負責檢查庫存並購買食材。</li>
                                <li><strong>備料 Agent：</strong> 負責清洗和切割食材。</li>
                                <li><strong>烹飪 Agent：</strong> 專注於烹飪菜餚。</li>
                                <li><strong>擺盤 Agent：</strong> 負責最後的裝飾和擺盤。</li>
                            </ul>
                            <p>一個「總廚」（Orchestrator）負責協調這些專門的 Agent，將前一個 Agent 的輸出（如切好的蔬菜）交給下一個 Agent。這種模式遠比一個從採購買到擺盤都自己來的全能廚師要高效和穩定得多。</p>
                        </blockquote>

                        <h3>為何重要？</h3>
                        <ul>
                            <li><strong>降低複雜性：</strong> 每個 Agent 的提示和邏輯都大大簡化。</li>
                            <li><strong>提高可靠性：</strong> 測試和驗證一個只做一件事的 Agent，遠比測試一個什麼都做的 Agent 容易。</li>
                            <li><strong>可重用性與可組合性：</strong> 您可以像組合樂高積木一樣，將這些小型 Agent 靈活地串聯起來，以應對不同的複雜工作流程。</li>
                        </ul>
                    </div>
                `
            },
            "factor-11": {
                "title": "XI. 從任何地方觸發",
                "icon": "ph-plugs-connected",
                "html": `
                    <div class="content-section">
                        <h2>第十一因子：Agent 應該可以被任何事件觸發，而非僅限於聊天</h2>
                        <p>Agent 的潛力遠不止於作為一個聊天機器人。一個設計良好的 Agent 應該是一個可以被整合到任何系統中的、獨立的自動化元件。它的生命週期（啟動、恢復）應該可以被各種外部事件所觸發。</p>
                         <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/1b0-trigger-from-anywhere.png" alt="從任何地方觸發示意圖">

                        <h3>核心理念：Agent 即服務 (Agent as a Service)</h3>
                        <p>將您的 Agent 視為一個可以透過 API 呼叫的後端服務。它的入口點不應該只有一個聊天視窗，而應該是各種系統事件。</p>
                        
                        <h3>觸發來源的想像</h3>
                        <p>想像一下，您的 Agent 可以被以下事件啟動：</p>
                        <ul>
                            <li><strong>Webhook 觸發：</strong> 當您的 GitHub 倉庫有新的程式碼提交時，自動觸發一個「程式碼審查 Agent」。</li>
                            <li><strong>電子郵件觸發：</strong> 當客服信箱收到一封新郵件時，自動觸發一個「工單分類 Agent」，分析郵件內容並建立 Jira 工單。</li>
                            <li><strong>排程任務觸發：</strong> 每天早上 8 點，一個 Cron Job 觸發「市場新聞摘要 Agent」，為您的團隊準備每日簡報。</li>
                            <li><strong>資料庫變更觸發：</strong> 當訂單資料庫中出現一筆新的「已付款」訂單時，觸發一個「訂單處理與出貨 Agent」。</li>
                        </ul>

                        <h3>為何重要？</h3>
                        <blockquote>這個原則將 Agent 從一個「前端玩具」解放出來，使其成為能夠深入整合到您現有業務流程中的「後端自動化引擎」。它要求我們的 Agent 架構（特別是因子六的生命週期 API）必須是事件驅動的，能夠處理非同步的、長時間運行的任務。</blockquote>
                    </div>
                `
            },
            "factor-12": {
                "title": "XII. 無狀態的歸納器（Reducer）",
                "icon": "ph-function",
                "html": `
                    <div class="content-section">
                        <h2>第十二因子：將 Agent 的核心邏輯視為一個無狀態的歸納器函式</h2>
                        <p>這是十二個因子中最具軟體工程思想、也是最核心的抽象原則。它將前面所有因子的實踐，昇華為一個優雅的、函數式的模型。其核心思想是：Agent 的整個執行過程，可以被看作是一個對狀態列表進行「歸納」（Reduce）的過程。</p>
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/1c5-agent-foldl.png" alt="無狀態的歸納器示意圖">
                        
                        <h3>核心理念：Agent 即純函式 (Agent as a Pure Function)</h3>
                        <p>Agent 的核心邏輯應該被封裝在一個單一的、無狀態的函式中。這個函式接收當前的完整狀態（即對話歷史），並回傳一個新的、更新後的狀態。它本身不儲存任何資訊，也沒有任何副作用。</p>

                        <h3>生活化譬喻：影片剪輯</h3>
                        <blockquote>您可以將 Agent 的執行歷史（因子五）想像成一條影片的時間軸，上面排列著一個個的事件片段。
                        <br><br>
                        而 \`agentReducer\` 函式就像是一位剪輯師。他看著目前為止的所有片段（輸入的 \`currentState\`），然後決定下一個要添加的片段是什麼（可能是 LLM 的思考，或是一個工具的結果），最後產生一條更長的新時間軸（回傳的 \`newState\`）。
                        <br><br>
                        這位剪輯師沒有記憶，他每一次做決定，都只依賴於他眼前所看到的這條完整的時間軸。
                        </blockquote>
                        
                        <h3>為何這是終極目標？</h3>
                        <ul>
                            <li><strong>極致的可測試性：</strong> 因為 \`agentReducer\` 是一個純函式（或接近純函式），測試它變得非常簡單。您只需要準備一個輸入的狀態（一份對話歷史），然後斷言它輸出的新狀態是否符合預期，完全不需要 Mock 或複雜的設定。</li>
                            <li><strong>可預測與可除錯：</strong> 系統的行為變得高度可預測。任何時候，您都可以透過查看輸入的狀態來理解 Agent 為何會做出某個決定。</li>
                            <li><strong>擴展性：</strong> 無狀態的函式可以輕易地被水平擴展，因為它們不依賴任何共享的記憶體或狀態。</li>
                        </ul>
                        <p>雖然 LLM 的存在讓這個函式並非 100% 的純粹（因為 LLM 有隨機性），但這種架構最大限度地隔離了不確定性，將系統的其他部分都保持在確定性的、可測試的狀態，是建構複雜、可靠 Agent 系統的黃金標準。</p>
                    </div>
                `
            }
        };

        document.addEventListener('DOMContentLoaded', function () {
            const sidebar = document.getElementById('sidebar');
            const sidebarNav = document.getElementById('sidebar-nav');
            const mainContent = document.getElementById('main-content');
            const menuToggle = document.getElementById('menu-toggle');
            const overlay = document.getElementById('overlay');

            const navItems = Object.keys(content);
            
            const createNavLinks = (container) => {
                container.innerHTML = '';
                navItems.forEach(key => {
                    const item = content[key];
                    const link = document.createElement('a');
                    link.href = `#${key}`;
                    link.innerHTML = `<i class="${item.icon} text-xl"></i><span>${item.title}</span>`;
                    link.className = 'flex items-center gap-3 py-2.5 px-4 rounded-lg text-slate-300 hover:bg-slate-700 hover:text-white transition-colors duration-200 sidebar-link';
                    link.dataset.section = key;
                    container.appendChild(link);
                });
            };
            
            createNavLinks(sidebarNav);

            const allLinks = document.querySelectorAll('.sidebar-link');

            const updateContent = (hash) => {
                const sectionKey = (hash && hash !== '#') ? hash.substring(1) : navItems[0];
                if (content[sectionKey]) {
                    window.scrollTo(0, 0);
                    mainContent.innerHTML = content[sectionKey].html;
                    allLinks.forEach(link => {
                        link.classList.toggle('active', link.dataset.section === sectionKey);
                    });
                }
            };
            
            const closeSidebar = () => {
                sidebar.classList.add('-translate-x-full');
                overlay.classList.add('hidden');
            };

            allLinks.forEach(link => {
                link.addEventListener('click', function (e) {
                    e.preventDefault();
                    const sectionKey = this.dataset.section;
                    history.pushState(null, null, `#${sectionKey}`);
                    updateContent(`#${sectionKey}`);
                    if (window.innerWidth < 1024) {
                        closeSidebar();
                    }
                });
            });

            menuToggle.addEventListener('click', function() {
                sidebar.classList.toggle('-translate-x-full');
                overlay.classList.toggle('hidden');
            });
            overlay.addEventListener('click', closeSidebar);
            
            updateContent(window.location.hash);

            window.addEventListener('popstate', () => {
                updateContent(window.location.hash);
            });
        });
    </script>

</body>
</html>

