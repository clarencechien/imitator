<!DOCTYPE html>
<html lang="zh-Hant" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12-Factor Agent 中文教學</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        :root {
            --sidebar-width: 18rem;
        }
        html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #0f172a; /* bg-slate-900 */
        }
        .sidebar-link.active {
            background-color: #1e40af; /* dark blue */
            color: #ffffff;
        }
        .content-section h2 {
            font-size: 2.25rem;
            font-weight: 700;
            letter-spacing: -0.025em;
            background: linear-gradient(to right, #60a5fa, #34d399);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #334155; /* gray-700 */
            margin-top: 3.5rem; /* Increased spacing */
            margin-bottom: 2.5rem; /* Increased spacing */
        }
        .content-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f3f4f6; /* gray-100 */
            margin-top: 3.5rem; /* Increased spacing */
            margin-bottom: 1.5rem; /* Increased spacing */
        }
        /* Adjusted text color and spacing for better readability */
        .content-section p, 
        .content-section ul, 
        .content-section ol {
            line-height: 1.8;
            color: #e5e7eb; /* Brighter text color (gray-200) */
            margin-bottom: 1.75rem; /* Increased spacing */
        }
        .content-section li {
            margin-bottom: 0.75rem;
        }
        .content-section ul li {
            list-style-type: none;
            position: relative;
            padding-left: 1.75rem;
        }
        .content-section ul li::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: #3b82f6; /* blue-500 */
            font-weight: bold;
        }
        .content-section ol {
            list-style-type: decimal;
            margin-left: 1.5rem;
        }
        .content-section code {
            background-color: #111827; /* gray-900 */
            color: #93c5fd; /* blue-300 */
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.9em;
        }
        .content-section pre {
            background-color: #030712; /* gray-950 */
            border: 1px solid #374151; /* gray-700 */
            padding: 1.25rem;
            border-radius: 0.75rem;
            overflow-x: auto;
            margin: 2.5rem 0;
        }
        .content-section blockquote {
            border-left: 4px solid #3b82f6; /* blue-500 */
            padding-left: 1.5rem;
            margin: 3rem 0; /* Increased spacing */
            color: #e5e7eb; /* gray-200 */
            background-color: #1f2937; /* gray-800 */
            padding-top: 1rem;
            padding-bottom: 1rem;
            border-radius: 0 0.5rem 0.5rem 0;
        }
        .content-section img {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            margin: 3rem auto; /* Increased spacing */
            border: 1px solid #374151; /* gray-700 */
            background-color: #111827;
            display: block;
        }
        .video-container {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            max-width: 100%;
            border-radius: 0.75rem;
            border: 1px solid #374151;
            margin: 2.5rem 0;
        }
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300">

    <div class="flex min-h-screen">
        <!-- Sidebar -->
        <aside id="sidebar" class="w-[var(--sidebar-width)] bg-slate-900/70 backdrop-blur-lg border-r border-slate-700 p-6 fixed h-full overflow-y-auto transition-transform -translate-x-full lg:translate-x-0 z-20">
            <div class="flex items-center gap-3 mb-8">
                <i class="ph-bold ph-brain text-3xl text-blue-400"></i>
                <h1 class="text-xl font-bold text-white">12-Factor Agent</h1>
            </div>
            <nav id="sidebar-nav" class="space-y-1">
                <!-- Links will be injected by JavaScript -->
            </nav>
        </aside>

        <!-- Main content -->
        <main class="flex-1 lg:ml-[var(--sidebar-width)] p-4 sm:p-6 lg:p-12">
            <!-- Adjusted max-width for better readability -->
            <div id="main-content" class="max-w-4xl mx-auto bg-slate-800/50 backdrop-blur-sm border border-slate-700 p-6 sm:p-8 lg:p-12 rounded-2xl">
                <!-- Content will be injected by JavaScript -->
            </div>
        </main>
        
        <!-- Mobile Header & Menu Button -->
        <header class="lg:hidden fixed top-0 left-0 right-0 bg-slate-900/80 backdrop-blur-md shadow-lg z-10 border-b border-slate-700">
            <div class="flex justify-between items-center p-4">
                <div class="flex items-center gap-3">
                    <i class="ph-bold ph-brain text-2xl text-blue-400"></i>
                    <h1 class="text-lg font-bold text-white">12-Factor Agent</h1>
                </div>
                <button id="menu-toggle" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-slate-500">
                     <i class="ph ph-list text-2xl text-white"></i>
                </button>
            </div>
        </header>
        <div id="overlay" class="fixed inset-0 bg-black/50 z-10 hidden lg:hidden"></div>

    </div>

    <script>
        const content = {
            "intro": {
                "title": "簡介與軟體發展簡史",
                "icon": "ph-rocket-launch",
                "html": `
                    <h2>簡介：為 AI Agent 建立可靠的方法論</h2>
                    <p>「12-Factor App」方法論在過去十年徹底改變了我們建構和部署網路應用程式的方式。然而，隨著大型語言模型（LLM）和 AI Agent 的興起，我們正面臨著新的挑戰。</p>
                    <p>AI Agent 的行為具有不確定性，這使得傳統的軟體工程實踐變得困難。這個專案提出的「12-Factor Agent」旨在借鏡「12-Factor App」的成功經驗，為建構、部署和維護可靠、可擴展且可維護的 AI Agent 提供一套指導原則。</p>
                    
                    <h3>軟體發展的演進</h3>
                    <p>軟體開發從單體應用程式，演進到由 Airflow、Kubernetes 等工具編排的有向無環圖（DAG），再到機器學習（ML）管線。現在，Agent 的出現引入了一種新的典範：由 LLM 驅動的迴圈（loop）取代了傳統 DAG 中的節點。這種 Agent 迴圈能夠根據上下文動態地決定下一步行動，但也帶來了可預測性和狀態管理的複雜性。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/027-agent-loop-dag.png" alt="Agent DAG 示意圖">
                    
                    <h3>核心挑戰</h3>
                    <p>我們面臨的核心挑戰是如何在 Agent 的靈活性和傳統軟體工程的嚴謹性之間找到平衡。這十二個因子就是為了解決這個問題而提出的。</p>

                    <h3>背景影片與摘要</h3>
                    <p>以下影片由「12-Factor Agent」的原作者 Dex Horthy 所演講，詳細闡述了這些原則背後的動機和觀察。觀看此影片將有助於更深入地理解為何我們需要一套新的方法論來建構可靠的 LLM 應用。</p>
                    <div class="video-container">
                       <iframe src="https://www.youtube.com/embed/8kMaTybvDUw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading="lazy"></iframe>
                    </div>
                    <h4>影片摘要：</h4>
                    <p>在這場演講中，Dex Horthy 探討了在建構 AI 代理時所遇到的普遍挑戰，特別是當品質達到一定瓶頸後難以突破的問題。基於與上百位開發者的交流，他總結出幾個關鍵模式：</p>
                    <ul>
                        <li>多數生產環境的「代理」更像是傳統軟體，而非完全自主的代理。</li>
                        <li>成功的關鍵在於應用軟體工程的基本原則，並將大型問題模組化。</li>
                        <li>開發者需要完全掌控代理的<strong>提示 (Prompts)</strong>、<strong>上下文建構 (Context Building)</strong> 和<strong>控制流 (Control Flow)</strong>，而不是依賴框架的黑箱作業。</li>
                        <li>將人類的互動視為一種工具呼叫、妥善處理錯誤、並傾向於建構小型、專注的「微代理」，是提升系統可靠性的重要策略。</li>
                    </ul>
                    <p>總結來說，Horthy 強調代理本身就是軟體，應遵循嚴謹的軟體工程實踐。LLM 作為一個無狀態函數，其可靠性高度依賴於開發者如何精確地提供上下文和引導其行為。</p>
                `
            },
            "factor-1": {
                "title": "I. 自然語言到工具呼叫",
                "icon": "ph-chat-circle-dots",
                "html": `
                    <h2>第一因子：將自然語言轉換為結構化的工具呼叫</h2>
                    <p>這是 Agent 的核心能力。Agent 的主要職責是接收自然語言指令，並將其轉化為一系列可執行的、結構化的工具（Tool）呼叫。這個過程是所有後續操作的基礎。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/110-natural-language-tool-calls.png" alt="自然語言到工具呼叫示意圖">
                    <h3>關鍵概念</h3>
                    <ul>
                        <li><strong>輸入：</strong> Agent 接收的通常是模糊、高層次的自然語言請求。</li>
                        <li><strong>處理：</strong> LLM 的推理能力被用來解析這個請求，理解其意圖，並決定需要使用哪些工具來完成任務。</li>
                        <li><strong>輸出：</strong> 最終的輸出應該是一個或多個定義清晰、參數明確的工具呼叫。例如，一個 JSON 物件，指定了工具名稱和所需的參數。</li>
                    </ul>
                    <blockquote>這個因子強調了 Agent 作為「翻譯者」的角色，在人類的意圖和機器的執行之間建立橋樑。</blockquote>
                `
            },
            "factor-2": {
                "title": "II. 掌握你的提示",
                "icon": "ph-scroll",
                "html": `
                    <h2>第二因子：程式碼與提示（Prompt）的分離與版本控制</h2>
                    <p>提示（Prompt）是 Agent 的「原始碼」，它定義了 Agent 的行為、個性和能力。因此，我們應該像管理程式碼一樣，嚴格地管理提示。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/120-own-your-prompts.png" alt="掌握你的提示示意圖">
                    <h3>最佳實踐</h3>
                    <ul>
                        <li><strong>版本控制：</strong> 將提示儲存在版本控制系統中（如 Git），而不是硬編碼在程式碼裡。這使得追蹤變更、協作和回滾變得容易。</li>
                        <li><strong>分離：</strong> 提示應該與應用程式邏輯分離。這樣，提示工程師可以在不需重新部署整個應用程式的情況下，迭代和優化提示。</li>
                        <li><strong>模板化：</strong> 使用提示模板來動態插入變數和上下文，這增加了提示的靈活性和重用性。</li>
                    </ul>
                    <p>這個原則借鑒了「設定與程式碼分離」的思想，將提示視為一種需要獨立管理的關鍵資產。</p>
                `
            },
             "factor-3": {
                "title": "III. 掌握你的上下文視窗",
                "icon": "ph-books",
                "html": `
                    <h2>第三因子：明確地建構與管理上下文</h2>
                    <p>上下文視窗（Context Window）是 LLM 的「短期記憶」。Agent 的表現極度依賴於我們如何有效地利用這個有限的空間。我們必須自己控制上下文的建構過程，而不是依賴於某個框架的黑箱操作。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/130-own-your-context-building.png" alt="掌握你的上下文視窗示意圖">
                    <h3>關鍵策略</h3>
                    <ul>
                        <li><strong>明確建構：</strong> 程式碼應該明確地定義哪些資訊被放入上下文中，包括系統提示、對話歷史、工具輸出和相關文件（RAG）。</li>
                        <li><strong>空間意識：</strong> Agent 需要意識到上下文視窗的大小限制。當內容過多時，需要有策略來進行摘要、過濾或捨棄，以確保最重要的資訊被保留。</li>
                        <li><strong>避免隱性狀態：</strong> 不要讓框架自動管理對話歷史或上下文。開發者需要完全控制權，以確保可預測性和可除錯性。</li>
                    </ul>
                    <blockquote>將上下文視窗的管理視為一門工程學問——「上下文工程」（Context Engineering），是建構高效 Agent 的關鍵。</blockquote>
                `
            },
            "factor-4": {
                "title": "IV. 工具即結構化輸出",
                "icon": "ph-wrench",
                "html": `
                    <h2>第四因子：將工具定義為 LLM 的結構化輸出</h2>
                    <p>工具（Tools）不僅僅是 Agent 可以呼叫的函式，它們更應該被視為 LLM 響應的強制結構。透過要求 LLM 以特定格式（如 JSON Schema）輸出，我們可以確保 Agent 的行為更加可靠和可預測。</p>
                     <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/140-tools-are-just-structured-outputs.png" alt="工具即結構化輸出示意圖">
                    <h3>核心思想</h3>
                    <ul>
                        <li><strong>強制結構：</strong> 利用 LLM 的函式呼叫（Function Calling）或工具使用（Tool Use）功能，來強制模型生成符合預定義 schema 的 JSON。</li>
                        <li><strong>可靠性：</strong> 這避免了從非結構化文本中解析意圖的不確定性，大大提高了 Agent 的可靠性。</li>
                        <li><strong>簡化邏輯：</strong> 應用程式的邏輯可以簡化為處理這些結構化輸出，而不是處理複雜的自然語言。</li>
                    </ul>
                    <p>這個因子將「工具使用」從一個模糊的概念，轉變為一個具體的、基於 schema 的介面，增強了系統的穩健性。</p>
                `
            },
            "factor-5": {
                "title": "V. 統一執行狀態",
                "icon": "ph-stack",
                "html": `
                    <h2>第五因子：將所有狀態統一到對話歷史中</h2>
                    <p>Agent 的狀態管理是其最複雜的部分之一。為了簡化它，我們應該將所有與執行相關的狀態——包括使用者輸入、工具呼叫、工具回傳結果、錯誤訊息——全部統一到一個線性的對話歷史記錄中。</p>
                     <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/155-unify-state-animation.gif" alt="統一執行狀態動畫">
                    <h3>優點</h3>
                    <ul>
                        <li><strong>單一事實來源：</strong> 對話歷史成為了 Agent 執行的唯一事實來源。這使得除錯、重播和分析變得非常簡單。</li>
                        <li><strong>無狀態邏輯：</strong> Agent 的核心邏輯可以被設計成無狀態的。它接收當前的對話歷史，然後決定下一步的行動，而不需要維護任何隱藏的內部狀態。</li>
                        <li><strong>持久化：</strong> 這個統一的對話歷史可以輕易地被序列化並儲存到資料庫中，從而實現執行的持久化。</li>
                    </ul>
                    <p>這個原則與第三因子（掌握上下文）密切相關。對話歷史是建構上下文視窗的主要輸入。</p>
                `
            },
            "factor-6": {
                "title": "VI. 啟動、暫停、恢復",
                "icon": "ph-play-pause",
                "html": `
                    <h2>第六因子：透過簡單的 API 介面控制 Agent 的生命週期</h2>
                    <p>Agent 的執行可能是長時間運行的，並且可能需要人類的介入。因此，我們需要一套簡單、標準的 API 來控制 Agent 的生命週期：啟動（Launch）、暫停（Pause）和恢復（Resume）。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/165-pause-resume-animation.gif" alt="啟動、暫停、恢復動畫">
                    <h3>API 設計</h3>
                    <ul>
                        <li><code><strong>Launch(input) -> state</strong></code>: 接收初始輸入，開始一個新的 Agent 執行緒，並返回其初始狀態。</li>
                        <li><code><strong>Resume(state) -> state</strong></code>: 接收一個被暫停的 Agent 狀態，讓它繼續執行一步或多步，然後返回更新後的狀態。</li>
                        <li><code><strong>Pause(state) -> state</strong></code>: （隱性操作）當 Agent 需要等待外部輸入（例如，人類的回饋或一個長時間運行的工具）時，它會進入暫停狀態。</li>
                    </ul>
                    <p>基於第五因子的統一狀態模型，這些 API 的實現變得非常簡單。它們只需要接收和返回那個包含完整對話歷史的狀態物件。</p>
                `
            },
            "factor-7": {
                "title": "VII. 透過工具與人互動",
                "icon": "ph-user-sound",
                "html": `
                    <h2>第七因子：將人類視為 Agent 可以呼叫的一種工具</h2>
                    <p>在許多場景下，Agent 需要人類的幫助、批准或提供額外資訊。與其將「人機互動」視為一個特殊的流程，不如將其模型化為 Agent 呼叫的一個普通工具。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/170-contact-humans-with-tools.png" alt="透過工具與人互動示意圖">
                    <h3>實現方式</h3>
                    <ul>
                        <li><strong>定義人類工具：</strong> 創建一個名為 <code>ask_human</code> 或 <code>request_approval</code> 的工具。這個工具的參數可能包括要問的問題、選項等。</li>
                        <li><strong>暫停與等待：</strong> 當 Agent 呼叫這個「人類工具」時，它的執行緒會被暫停（因子六），等待人類的回應。</li>
                        <li><strong>恢復執行：</strong> 人類透過某個介面（如 Slack、Email、Web UI）提供輸入後，這個輸入會被格式化為工具的輸出，然後 Agent 的執行緒會被恢復（因子六），並將這個結果添加到對話歷史中。</li>
                    </ul>
                    <blockquote>這種方法統一了 Agent 與外部世界的互動方式，無論是呼叫一個 API，還是請求人類的幫助，都遵循同樣的模式。</blockquote>
                `
            },
            "factor-8": {
                "title": "VIII. 掌握你的控制流",
                "icon": "ph-git-branch",
                "html": `
                    <h2>第八因子：由你的程式碼（而非框架）來決定控制流</h2>
                    <p>許多現有的 Agent 框架試圖隱藏其內部的控制流（通常是一個 while 迴圈）。然而，這種黑箱操作會導致客製化困難和行為難以預測。我們應該反過來，由我們自己的應用程式程式碼來明確地編寫和管理這個迴圈。</p>
                     <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/180-control-flow.png" alt="掌握你的控制流示意圖">
                    <h3>一個簡單的 Agent 迴圈範例</h3>
                    <pre><code class="language-typescript">
// 由你自己的程式碼來編寫這個迴圈
let currentState = agent.launch("我的初始請求");

while (!currentState.isDone()) {
  if (currentState.requiresHumanInput()) {
    const humanResponse = await waitForHuman(currentState);
    currentState.addToolResponse('ask_human', humanResponse);
  }

  currentState = await agent.resume(currentState);
}

console.log(currentState.finalAnswer);
                    </code></pre>
                    <h3>優點</h3>
                    <ul>
                        <li><strong>完全控制：</strong> 你可以完全控制 Agent 的每一步執行，例如決定迴圈的終止條件、處理特定狀態、或在步驟之間插入自訂邏輯。</li>
                        <li><strong>透明度：</strong> Agent 的行為變得完全透明和可預測。</li>
                        <li><strong>可除錯性：</strong> 在迴圈的每一步都可以輕鬆地印出日誌、檢查狀態，從而簡化除錯過程。</li>
                    </ul>
                `
            },
            "factor-9": {
                "title": "IX. 緊湊的錯誤訊息",
                "icon": "ph-bug",
                "html": `
                    <h2>第九因子：將錯誤視為上下文的一部分並使其緊湊</h2>
                    <p>工具執行失敗是常態。當錯誤發生時，我們不應該讓程式崩潰，而是應該將錯誤訊息捕獲，並將其作為工具的輸出返回給 Agent。重要的是，這個錯誤訊息必須是緊湊且資訊豐富的，因為它會佔用寶貴的上下文視窗空間。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/195-factor-9-errors.gif" alt="緊湊的錯誤訊息動畫">
                    <h3>錯誤處理流程</h3>
                    <ol>
                        <li>工具執行失敗，拋出一個例外。</li>
                        <li>應用程式的控制流（你的迴圈）捕獲這個例外。</li>
                        <li>將完整的錯誤堆疊（stack trace）記錄到日誌系統中供開發者分析。</li>
                        <li>生成一個簡潔、對 LLM 友好的錯誤摘要（例如：「API 請求失敗，狀態碼 404 - 未找到資源」）。</li>
                        <li>將這個摘要作為工具的輸出，添加到對話歷史中。</li>
                        <li>Agent 在下一步的推理中，會看到這個錯誤訊息，並可以嘗試修復它（例如，修正參數後重試）。</li>
                    </ol>
                    <p>這種方法讓 Agent 具備了自我修正的能力，同時也避免了上下文視窗被冗長的錯誤日誌所污染。</p>
                `
            },
            "factor-10": {
                "title": "X. 小型、專注的 Agent",
                "icon": "ph-puzzle-piece",
                "html": `
                    <h2>第十因子：傾向於組合多個小型、專注的 Agent</h2>
                    <p>與其建立一個試圖做所有事情的巨大、單體的 Agent，不如建立多個小型的、只專注於單一職責的 Agent。然後，透過將一個 Agent 的輸出作為另一個 Agent 的輸入，來將它們組合起來，完成更複雜的任務。</p>
                     <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/1a5-agent-scope-grow.gif" alt="Agent 範疇擴張問題動畫">
                    <h3>微服務架構的啟示</h3>
                    <p>這個原則借鑒了軟體工程中的微服務（Microservices）架構思想。</p>
                    <ul>
                        <li><strong>單一職責：</strong> 每個 Agent 都有一個明確且有限的職責（例如，「研究員 Agent」、「程式碼撰寫 Agent」、「部署 Agent」）。</li>
                        <li><strong>易於維護：</strong> 小型的 Agent 更容易理解、測試和維護。它們的提示也更簡單，更容易優化。</li>
                        <li><strong>可組合性：</strong> 就像樂高積木一樣，這些小型的 Agent 可以被靈活地組合，以應對各種不同的複雜任務。</li>
                        <li><strong>獨立部署：</strong> 每個 Agent 都可以被獨立開發和部署。</li>
                    </ul>
                    <p>這種方法提高了系統的模組化程度、可擴展性和整體的可維護性。</p>
                `
            },
            "factor-11": {
                "title": "XI. 從任何地方觸發",
                "icon": "ph-plugs-connected",
                "html": `
                    <h2>第十一因子：Agent 應該可以被任何事件觸發，而非僅限於聊天</h2>
                    <p>許多人對 Agent 的印象停留在一個聊天機器人介面。然而，一個真正強大的 Agent 系統應該能夠被各種事件觸發，並在背景中自主運行。</p>
                     <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/1b0-trigger-from-anywhere.png" alt="從任何地方觸發示意圖">
                    <h3>觸發來源範例</h3>
                    <ul>
                        <li><strong>Webhook：</strong> 一個 GitHub 的 push 事件可以觸發一個「部署 Agent」。</li>
                        <li><strong>排程任務 (Cron Job)：</strong> 一個每天執行的排程任務可以觸發一個「每日報告生成 Agent」。</li>
                        <li><strong>電子郵件：</strong> 收到一封特定格式的郵件可以觸發一個「客戶服務 Agent」。</li>
                        <li><strong>資料庫變更：</strong> 資料庫中某個記錄的狀態改變可以觸發一個「訂單處理 Agent」。</li>
                    </ul>
                    <p>為了實現這一點，Agent 的啟動（Launch）和恢復（Resume）API（因子六）需要被設計成可以輕易地與各種事件驅動的系統整合。這將 Agent 從一個被動的聊天夥伴，轉變為一個主動的、自動化的工作流程執行者。</p>
                `
            },
            "factor-12": {
                "title": "XII. 無狀態的歸納器（Reducer）",
                "icon": "ph-function",
                "html": `
                    <h2>第十二因子：將 Agent 的核心邏輯視為一個無狀態的歸納器函式</h2>
                    <p>這個因子是前面所有原則的總結和昇華。我們可以將 Agent 的核心邏輯抽象成一個純粹的、無狀態的函式，其行為類似於函數式程式設計中的 \`reduce\`（或 \`foldl\`）操作。</p>
                    <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/d20c728368bf9c189d6d7aab704744decb6ec0cc/img/1c5-agent-foldl.png" alt="無狀態的歸納器示意圖">
                    <h3>函式簽名</h3>
                    <pre><code class="language-typescript">
type AgentState = {
  history: DialogueTurn[],
  // ... 其他元數據
}

// Agent 的核心就是這個函式
function agentReducer(currentState: AgentState): Promise&lt;AgentState&gt; {
  // 1. 根據 currentState.history 建構上下文 (因子三)
  // 2. 呼叫 LLM 取得下一步的工具呼叫 (因子一、四)
  // 3. 執行工具，處理錯誤 (因子九)
  // 4. 將結果加入歷史，產生 newState
  // 5. 返回 newState
}
                    </code></pre>
                    <h3>核心特性</h3>
                    <ul>
                        <li><strong>無狀態 (Stateless)：</strong> 這個函式本身不儲存任何狀態。所有的狀態都來自於輸入的 \`currentState\`。</li>
                        <li><strong>確定性 (Deterministic)：</strong> 給定相同的輸入狀態，它應該（在理想情況下，忽略 LLM 的隨機性）產生相同的輸出狀態。這使得測試變得極為容易。</li>
                        <li><strong>可組合性：</strong> 整個 Agent 的執行過程，就是反覆地將這個 \`agentReducer\` 函式應用到狀態上，直到達到終止條件。<code>newState &#61; reduce(history, reducerFn)</code>。</li>
                    </ul>
                    <p>將 Agent 視為一個無狀態的歸納器，是實現可靠、可測試和可維護的 AI 系統的終極目標。</p>
                `
            }
        };

        document.addEventListener('DOMContentLoaded', function () {
            const sidebar = document.getElementById('sidebar');
            const sidebarNav = document.getElementById('sidebar-nav');
            const mainContent = document.getElementById('main-content');
            const menuToggle = document.getElementById('menu-toggle');
            const overlay = document.getElementById('overlay');

            const navItems = Object.keys(content);
            
            const createNavLinks = (container) => {
                container.innerHTML = '';
                navItems.forEach(key => {
                    const item = content[key];
                    const link = document.createElement('a');
                    link.href = `#${key}`;
                    link.innerHTML = `<i class="${item.icon} text-xl"></i><span>${item.title}</span>`;
                    link.className = 'flex items-center gap-3 py-2.5 px-4 rounded-lg text-slate-300 hover:bg-slate-700 hover:text-white transition-colors duration-200 sidebar-link';
                    link.dataset.section = key;
                    container.appendChild(link);
                });
            };
            
            createNavLinks(sidebarNav);

            const allLinks = document.querySelectorAll('.sidebar-link');

            const updateContent = (hash) => {
                const sectionKey = (hash && hash !== '#') ? hash.substring(1) : navItems[0];
                if (content[sectionKey]) {
                    window.scrollTo(0, 0);
                    // This is the key fix: wrap the injected content to apply styles
                    mainContent.innerHTML = `<div class="content-section">${content[sectionKey].html}</div>`;
                    allLinks.forEach(link => {
                        link.classList.toggle('active', link.dataset.section === sectionKey);
                    });
                }
            };
            
            const closeSidebar = () => {
                sidebar.classList.add('-translate-x-full');
                overlay.classList.add('hidden');
            };

            allLinks.forEach(link => {
                link.addEventListener('click', function (e) {
                    e.preventDefault();
                    const sectionKey = this.dataset.section;
                    history.pushState(null, null, `#${sectionKey}`);
                    updateContent(`#${sectionKey}`);
                    if (window.innerWidth < 1024) {
                        closeSidebar();
                    }
                });
            });

            menuToggle.addEventListener('click', function() {
                sidebar.classList.toggle('-translate-x-full');
                overlay.classList.toggle('hidden');
            });
            overlay.addEventListener('click', closeSidebar);
            
            updateContent(window.location.hash);

            window.addEventListener('popstate', () => {
                updateContent(window.location.hash);
            });
        });
    </script>

</body>
</html>

